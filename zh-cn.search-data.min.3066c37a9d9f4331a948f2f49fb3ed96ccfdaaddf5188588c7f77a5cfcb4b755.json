[{"id":0,"href":"/spring-doc/core/beans/","title":"1. IoC容器","section":"核心技术","content":"1. IoC容器 #  Version 5.2.2.RELEASE\n 本章介绍Spring的控制反转（IoC）容器。\n"},{"id":1,"href":"/spring-doc/core/beans/beans-introduction/","title":"1.1 Spring IoC容器和Beans简介","section":"1. IoC容器","content":"1.1 Spring IoC容器和Beans简介 #  Version 5.2.2.RELEASE\n 本章介绍Spring框架中控制反转（IoC）理念的实现。IoC也称为依赖注入（DI）。这是一个过程，对象仅通过构造函数参数、工厂方法的参数、在对象实例构造或从工厂方法返回后在对象实例上设置的属性来定义它们的依赖关系（即它们使用的其他对象）。然后，容器在创建这个bean时注入这些依赖项。这个过程基本上是bean本身通过使用类的直接构造或服务定位器模式等机制来控制其依赖项的实例化或位置完全相反（因此称为控制反转）。\norg.springframework.bean和org.springframework.context包是Spring框架中IoC容器的基础。BeanFactory接口提供了一种高级配置机制，能够管理任何类型的对象。ApplicationContext是BeanFactory的子接口。它补充了：\n 更容易与Spring的AOP功能集成 信息资源处理（用于国际化） 事件发布 应用层特定的上下文，如web应用程序中使用的WebApplicationContext。  简而言之，BeanFactory提供了配置框架和基本功能，ApplicationContext添加了更多特定于企业级的功能。ApplicationContext是BeanFactory的完整超集，在本章中专门用于描述Spring的IoC容器。有关使用BeanFactory而不是ApplicationContext的更多信息，请参阅[BeanFactory]。\n在Spring中，构成应用程序主干并由Spring IoC容器管理的对象称为bean。bean是由Spring IoC容器实例化、装配和管理的对象。除此之外，bean只是应用程序许多对象中的一个。bean以及它们之间的依赖关系反映在容器所使用的配置元数据中。\n"},{"id":2,"href":"/spring-doc/overview/","title":"Spring框架概述","section":"Spring框架文档","content":"Spring框架概述 #  Version 5.2.2.RELEASE\n Spring让创建企业级的Java应用变得更简单。它提供了在企业环境中使用Java语言所需的一切，支持Groovy和Kotlin作为JVM上的替代语言，并具有根据应用程序的需要而创建多种体系结构的灵活性。从Spring框架5.1开始，Spring需要JDK8+（Java SE 8+）并为JDK 11 LTS提供开箱即用的支持。建议使用Java SE 8 update 60作为Java 8的最低补丁版本，但通常更建议使用最新的补丁版本。\nSpring支持广泛的应用场景。在大型企业中，应用程序通常存在了很长时间，并且必须在JDK和应用程序服务器上运行，其升级周期超出了开发人员的控制。其他的可能作为一个jar运行，服务器可能嵌入到云环境中。还有一些可能是不需要服务器的独立应用程序（如批处理或集成工作负载）。\nSpring是开源的。它有一个庞大而活跃的社区，根据各种各样的实际用例提供持续的反馈。这帮助Spring在很长一段时间内成功地进化。\n1. 我们所说的“Spring” #  “Spring”一词在不同的语境中意味着不同的事物。它可以用来指代Spring框架项目本身，而Spring正是从这里开始的。随着时间的推移，其他Spring项目已经构建在Spring框架之上。通常，当人们说“Spring”时，他们指的是整个项目家族。这份参考文档主要关注Spring的基础：Spring框架本身。\nSpring框架分为几个模块，应用程序可以选择他们需要的模块。核心容器模块是核心，包括了配置模型和依赖注入机制。除此之外，Spring框架还为不同的应用程序体系结构提供了基础支持，包括消息传递、事务数据和持久化以及web服务。它还包括基于Servlet的Spring MVC框架和Spring WebFlux反应式web框架。\n关于模块的注意事项：Spring的framework jar允许部署到Jdk9的模块路径（“Jigsaw”）。为了在开启Jigsaw的应用程序中使用，Spring框架5个jar附带了“Automatic-Module-Name”清单条目，这些条目定义了独立于jar artifact的稳定语言级模块名（“spring.core”、“spring.context”等）（jar遵循相同的命名模式，用“-”代替“.”，例如“spring-core”和“spring-context”）。当然，Spring的framework jar在JDK8和JDK9+上的类路径上都能正常工作。\n 2. Spring和Spring框架的历史 #  Spring作为对早期J2EE规范复杂性的解决方案于2003年诞生。虽然有些人认为Java EE和Spring将处于竞争状态，但实际上，Spring是java EE的补充。Spring编程模型不支持Java EE的平台规范；相反，它与从EE旗下精心挑选的单个规范相结合：\n Servlet API (JSR 340) WebSocket API (JSR 356) Concurrency Utilities (JSR 236) JSON Binding API (JSR 367) Bean Validation (JSR 303) JPA (JSR 338) JMS (JSR 914) 以及JTA/JCA设置，以便在必要时进行事务协调。  Spring框架还支持依赖注入（JSR 330）和公共注解（JSR 250）规范，应用程序开发人员可以选择使用这些规范来代替Spring框架提供的特定于Spring的机制。\n从Spring Framework 5.0开始，Spring至少需要Java EE 7的级别（例如Servlet 3.1+，JPA 2.1+），同时在运行时遇到Java EE 8级别的新API（例如Servlet 4.0，JSON Binding API）时提供开箱即用的集成。这使得Spring与Tomcat 8和9、WebSphere 9和JBoss EAP 7完全兼容。\n随着时间的推移，Java EE在应用程序开发中的角色已经发生了变化。在Java EE和Spring的早期，创建的应用程序被部署到应用服务器上。今天，在SpringBoot的帮助下，应用程序只需要微不足道的改动就可以通过嵌入式Servlet容器以devops和云友好的方式创建的。从Spring Framework 5开始，WebFlux应用程序甚至不直接使用Servlet API，可以在不是Servlet容器的服务器（比如Netty）上运行。\nSpring将继续创新和进化。除了Spring框架，还有其他项目，比如Spring Boot、Spring Security、Spring Data、Spring Cloud、Spring Batch等等。重要的是要记住，每个项目都有自己的代码库、问题跟踪器和发布节奏。有关Spring项目的完整列表，请参见spring.io/projects。\n 3. 设计理念 #  当您学习一个框架时，不仅要知道它做什么，还要知道它遵循什么原则。以下是Spring框架的指导原则：\n 在各个级别提供选择。Spring允许您尽可能推迟设计决策。例如，您可以通过配置切换持久化提供程序，而无需更改代码。许多其他基础架构问题和与第三方API的集成也是如此。 适应不同的视角。Spring具有灵活性，对于应该如何做并不固执己见。它以不同的视角支持广泛的应用需求。 保持强大的向后兼容性。Spring的发展经过了精心管理，在版本之间几乎没有突破性的变化。Spring支持一系列经过精心挑选的JDK版本和第三方库，以便于维护依赖Spring的应用程序和库。 注重API设计。Spring团队投入了大量的精力和时间来创建直观的API，这些API可以跨多个版本和多年使用。 为代码质量设置高标准。Spring框架非常强调有意义、最新和准确的javadoc。它是为数不多的几个可以声明代码结构清晰、包之间没有循环依赖关系的项目之一。   4. 反馈和贡献 #  对于“how-to”类的问题或诊断、调试问题，我们建议使用StackOverflow，并且我们有一个问题页面，其中列出了建议使用的标记。如果您非常确定Spring框架中存在问题，或者想建议一个特性，请使用GitHub Issues。\n如果您有一个解决方案或建议的修复方案，您可以在Github上提交一个pull请求。但是，请记住，对于除最琐碎的问题外的所有问题，我们希望在问题跟踪器中提交一张记录单，在那里进行讨论并留下记录以供将来参考。\n有关更多详细信息，请参见参与顶级项目页面上的指导原则。\n 5. 入门 #  如果您刚刚开始使用Spring，那么您可能希望通过创建一个基于Spring Boot的应用程序来开始使用Spring框架。Spring Boot提供了一种快速（而且固定）的方法来创建一个基于Spring的准生产应用程序。它基于Spring框架，推崇约定大于配置，旨在让您尽快启动并运行。\n您可以使用start.spring.io生成一个基本项目，或者依照某个“指南”，例如：构建RESTful Web 服务指南。除了更容易理解之外，这些指南非常聚焦于task，而且大多数都是基于Spring Boot的。它们还涵盖了在解决特定问题时可能需要考虑的Spring文件夹中的其他项目。\n"},{"id":3,"href":"/spring-doc/core/beans/beans-basics/","title":"1.2 容器概述","section":"1. IoC容器","content":"1.2 容器概述 #  Version 5.2.2.RELEASE\n org.springframework.context.ApplicationContext接口就是Spring IoC容器，负责实例化、配置和装配bean。容器通过读取配置元数据获取关于实例化、配置和装配哪些对象的指令。配置元数据用XML、Java注解或Java代码表示，它可以用来表示组成应用程序的对象以及这些对象之间丰富的相互依赖关系。\nSpring提供了ApplicationContext接口的几种实现。在独立的应用中，通常创建的是ClassPathXmlApplicationContext或FileSystemXmlApplicationContext的实例。虽然XML一直是传统的定义配置元数据的格式，但您仍然可以使用Java注解或代码作为元数据格式，只需要通过提供少量XML配置来显式地开启对这些其他元数据格式的支持。\n在大多数应用程序场景中，实例化Spring IoC容器的一个或多个实例不需要显式的用户代码。例如，在web应用程序场景中，应用程序的样板web描述XML web.xml 中简单的八行（大约八行）通常就足够了（请参见[Web应用简单的ApplicationContext实例化]）。如果您使用Spring Tool Suite（Eclipse驱动的开发环境），只需单击几下鼠标或按键，就可以轻松创建此样板配置。\n下图展示了Spring如何工作的高等级视图。您的应用程序类与配置元数据相结合，在创建和初始化ApplicationContext后，您便拥有了一个完全配置好且可执行的系统或应用程序。\n 图1. Spring IoC容器   1.2.1 配置元数据 #  如上图所示，Spring IoC容器使用一种形式的配置元数据。此配置元数据表示作为应用程序开发人员，您如何告知Spring容器实例化、配置和组装您应用程序中的对象。\n配置元数据传统上是以简单直观的XML格式提供的，本章大部分内容用它来表达Spring IoC容器的关键概念和特性的。\n基于XML的元数据不是唯一允许的配置元数据形式。Spring IoC容器本身与实际写入此配置元数据的格式完全解耦。现在，许多开发人员为他们的Spring应用选择基于Java的配置。  有关在Spring容器中使用其他形式元数据的信息，请参阅：\n 基于注解的配置：Spring 2.5引入了对基于注解的配置元数据的支持。 基于Java的配置：从Spring 3.0开始，Spring JavaConfig项目提供的许多特性成为了核心Spring框架的一部分。因此，您可以使用Java而不是XML文件来定义应用程序类外的bean。要使用这些新功能，请参阅@Configuration、@Bean、@Import和@DependsOn注解。  Spring配置至少包括一个但通常不止一个必须由容器管理的bean定义。基于XML的配置元数据将这些bean配置为顶级\u0026lt;beans/\u0026gt;元素中的\u0026lt;bean/\u0026gt;元素。Java配置通常在@Configuration类中使用@Bean注解标注的方法来定义bean。\n这些bean定义对应着构成应用程序的实际对象。通常，您定义服务层对象、数据访问对象（DAO）、表示对象（如Struts中的Action实例）、基础结构对象（如Hibernate SessionFactorys）、JMS Queues等。通常，不在容器中配置细粒度域对象，因为创建和加载域对象通常是DAO和业务逻辑的责任。但是，您可以使用Spring与AspectJ的集成来配置在IoC容器控制之外创建的对象。请参阅在Spring中使用AspectJ注入依赖域对象。\n以下示例显示了基于XML的配置元数据的基本结构：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;...\u0026#34; class=\u0026#34;...\u0026#34;\u0026gt; 1 2 \u0026lt;!-- 此处是当前bean的协作者和配置 --\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;...\u0026#34; class=\u0026#34;...\u0026#34;\u0026gt; \u0026lt;!-- 此处是当前bean的协作者和配置 --\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!-- 此处是其他的bean定义 --\u0026gt; \u0026lt;/beans\u0026gt;   1   id属性是标识单个bean定义的字符串。     2   class属性定义bean的类型并且要使用全限定的类名。    id属性的值引用协作对象。本例中的XML未展示引用协作对象。有关更多信息，请参阅依赖。\n1.2.2 初始化容器 #  传给ApplicationContext构造函数的位置路径（可以有多个）是资源字符串，容器将从各种外部资源（如本地文件系统、Java CLASSPATH等）加载配置元数据。\nJava ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;services.xml\u0026#34;, \u0026#34;daos.xml\u0026#34;); Kotlin val context = ClassPathXmlApplicationContext(\u0026#34;services.xml\u0026#34;, \u0026#34;daos.xml\u0026#34;)  在了解Spring的IoC容器之后，您可能想进一步了解Spring的Resource抽象（如[资源]中所述），它提供了一种方便的机制，通过URI语法定义的位置读取输入流。具体而言，Resource路径用于构建应用上下文，如[应用上下文与资源路径]中所述。  以下示例展示了服务层对象(services.xml)配置文件：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;!-- services --\u0026gt; \u0026lt;bean id=\u0026#34;petStore\u0026#34; class=\u0026#34;org.springframework.samples.jpetstore.services.PetStoreServiceImpl\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;accountDao\u0026#34; ref=\u0026#34;accountDao\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;itemDao\u0026#34; ref=\u0026#34;itemDao\u0026#34;/\u0026gt; \u0026lt;!-- 此处是当前bean的其他协作者和配置 --\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!-- 此处是其他服务的bean定义 --\u0026gt; \u0026lt;/beans\u0026gt; 以下示例展示了数据访问对象daos.xml文件：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;accountDao\u0026#34; class=\u0026#34;org.springframework.samples.jpetstore.dao.jpa.JpaAccountDao\u0026#34;\u0026gt; \u0026lt;!-- 此处是当前bean的其他协作者和配置 --\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;itemDao\u0026#34; class=\u0026#34;org.springframework.samples.jpetstore.dao.jpa.JpaItemDao\u0026#34;\u0026gt; \u0026lt;!-- 此处是当前bean的其他协作者和配置 --\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!-- 此处是其他数据访问对象的bean定义 --\u0026gt; \u0026lt;/beans\u0026gt; 在前面的示例中，服务层由PetStoreServiceImpl类和两个类型为JpaAccountDao和JpaItemDao（基于JPA对象关系映射标准）的数据访问对象组成。property name元素指JavaBean属性的名称，ref元素指另一个bean定义的名称。id和ref元素之间的联动表示协作对象之间的依赖关系。有关配置对象依赖的详细信息，请参见依赖。\n组合基于XML的配置元数据 #  让bean定义可以跨多个XML文件非常有用。通常，每个单独的XML配置文件都表示体系结构中的一个逻辑层或模块。\n您可以使用应用上下文构造函数从所有这些XML片段中加载bean定义。此构造函数可以获取多个Resource位置，如前一节所示。或者，使用一个或多个\u0026lt;import/\u0026gt;元素从另一个或多个文件中加载bean定义。以下示例展示了如何执行此操作：\n\u0026lt;beans\u0026gt; \u0026lt;import resource=\u0026#34;services.xml\u0026#34;/\u0026gt; \u0026lt;import resource=\u0026#34;resources/messageSource.xml\u0026#34;/\u0026gt; \u0026lt;import resource=\u0026#34;/resources/themeSource.xml\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;bean1\u0026#34; class=\u0026#34;...\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;bean2\u0026#34; class=\u0026#34;...\u0026#34;/\u0026gt; \u0026lt;/beans\u0026gt; 在前面的示例中，外部bean定义从三个文件中加载：services.xml、messageSource.xml和themeSource.xml。所有位置路径都是执行导入的定义文件的相对路径，因此services.xml必须与执行导入的文件位于同一目录或类路径位置，而messageSource.xml和themeSource.xml必须位于导入文件位置的resources目录下。如您所见，前面的斜杠被忽略了。然而，考虑到这些路径是相对的，最好不要使用斜杠。根据Spring Schema，要导入文件的内容包括顶级\u0026lt;beans/\u0026gt;元素，而且必须是有效的XML bean定义。\n可以使用相对“../”路径引用父目录中的文件，但不建议这么做。这样做会创建对当前应用之外的文件的依赖关系。特别是，不建议对classpath:URLs（例如，classpath:../services.xml）使用此引用，它在运行时解析过程中选择“最近的”类路径root，然后查看其父目录。类路径配置更改可能会导致选择不同的、不正确的目录。\n您始终可以使用完全限定的资源位置而不是相对路径：例如，file:C:/config/services.xml或classpath:/config/services.xml。但是，请注意，您正在将应用程序的配置耦合到特定的绝对位置。通常，最好让此类绝对位置是间接的 — 例如，在运行时通过“${…}\u0026ldquo;解析JVM系统属性的占位符获取。\n 命名空间本身提供导入指令功能。Spring提供的一系列XML命名空间中提供了普通bean定义之外的更多配置特性 — 例如，context和util命名空间。\nGroovy Bean 定义 DSL #  作为外部化配置元数据的另一个示例，bean定义也可以在Spring的Groovy Bean定义DSL中表示，正如所熟知的Grails框架那样。通常，此类配置位于“.groovy”文件中，其结构如以下示例所示：\nbeans { dataSource(BasicDataSource) { driverClassName = \u0026#34;org.hsqldb.jdbcDriver\u0026#34; url = \u0026#34;jdbc:hsqldb:mem:grailsDB\u0026#34; username = \u0026#34;sa\u0026#34; password = \u0026#34;\u0026#34; settings = [mynew:\u0026#34;setting\u0026#34;] } sessionFactory(SessionFactory) { dataSource = dataSource } myService(MyService) { nestedBean = { AnotherBean bean -\u0026gt; dataSource = dataSource } } } 这种配置风格在很大程度上等同于XML bean定义，甚至支持Spring的XML配置命名空间。它还允许通过importBeans指令导入XML bean定义文件。\n1.2.3 使用容器 #  ApplicationContext是高级工厂的接口，能够维护不同bean的注册及其依赖。通过使用方法T getBean(String name, Class\u0026lt;T\u0026gt; requiredType)，您可以取到bean的实例。\nApplicationContext允许您读取bean定义并访问它们，如下例所示：\nJava // 创建并配置bean ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;services.xml\u0026#34;, \u0026#34;daos.xml\u0026#34;); // 获取配置好的实例 PetStoreService service = context.getBean(\u0026#34;petStore\u0026#34;, PetStoreService.class); // 使用配置好的实例 List\u0026lt;String\u0026gt; userList = service.getUsernameList(); Kotlin import org.springframework.beans.factory.getBean // 创建并配置bean val context = ClassPathXmlApplicationContext(\u0026#34;services.xml\u0026#34;, \u0026#34;daos.xml\u0026#34;) // 获取配置好的实例 val service = context.getBean\u0026lt;PetStoreService\u0026gt;(\u0026#34;petStore\u0026#34;) // 使用配置好的实例 var userList = service.getUsernameList()  对于Groovy配置，引导看起来非常相似。它有一个不同的上下文实现类，是识别Groovy的（但也能识别XML bean定义）。以下示例展示了Groovy配置：\nJava ApplicationContext context = new GenericGroovyApplicationContext(\u0026#34;services.groovy\u0026#34;, \u0026#34;daos.groovy\u0026#34;); Kotlin val context = GenericGroovyApplicationContext(\u0026#34;services.groovy\u0026#34;, \u0026#34;daos.groovy\u0026#34;)  最灵活的变种是GenericApplicationContext与读取器（reader）的组合 — 例如，对于XML文件使用XmlBeanDefinitionReader，如下例所示：\nJava GenericApplicationContext context = new GenericApplicationContext(); new XmlBeanDefinitionReader(context).loadBeanDefinitions(\u0026#34;services.xml\u0026#34;, \u0026#34;daos.xml\u0026#34;); context.refresh(); Kotlin val context = GenericApplicationContext() XmlBeanDefinitionReader(context).loadBeanDefinitions(\u0026#34;services.xml\u0026#34;, \u0026#34;daos.xml\u0026#34;) context.refresh()  当然，对于Groovy文件，您还可以使用GroovyBeanDefinitionReader，如下例所示：\nJava GenericApplicationContext context = new GenericApplicationContext(); new GroovyBeanDefinitionReader(context).loadBeanDefinitions(\u0026#34;services.groovy\u0026#34;, \u0026#34;daos.groovy\u0026#34;); context.refresh(); Kotlin val context = GenericApplicationContext() GroovyBeanDefinitionReader(context).loadBeanDefinitions(\u0026#34;services.groovy\u0026#34;, \u0026#34;daos.groovy\u0026#34;) context.refresh()  您可以在同一ApplicationContext上混合使用这些读取器（reader），以从不同的配置源读取bean定义。\n然后可以使用getBean获取bean的实例。ApplicationContext接口还有有一些其他方法用于获取bean，但是，理想情况下，应用程序代码中不应该使用它们。实际上，您的应用程序代码中应该根本没有对getBean()方法的调用，因此也完全不依赖于Spring的API。例如，Spring与web框架的集成为各种web框架组件（如控制器和JSF托管bean）提供了依赖项注入，允许您通过元数据（如自动注入注解）声明对特定bean的依赖。\n"},{"id":4,"href":"/spring-doc/core/","title":"核心技术","section":"Spring框架文档","content":"核心技术 #  Version 5.2.2.RELEASE\n 参考文档的这一部分涵盖了Spring框架中绝对不可或缺的所有技术。\n其中最重要的是Spring框架的控制反转（IoC）容器。在对Spring框架的IoC容器进行彻底的探讨之后，Spring的面向切面编程（AOP）技术得到了全面的介绍。Spring框架有自己的AOP框架，在概念上很容易理解，它成功地解决了Java企业级编程中80%的AOP需求。\nSpring与AspectJ集成的报道（目前最丰富 — 就特征而言 — 当然，也提供了Java企业空间中最成熟的AOP实现。\n还介绍了Spring与AspectJ（就特征而言是目前最丰富的，当然也是Java企业级领域内最成熟的AOP实现）的集成。\n"},{"id":5,"href":"/spring-doc/core/beans/beans-definition/","title":"1.3 Bean概述","section":"1. IoC容器","content":"1.3 Bean概述 #  Version 5.2.2.RELEASE\n Spring IoC容器管理着一个或多个bean。这些bean是基于您提供给容器的配置元数据创建的（例如，以XML\u0026lt;bean/\u0026gt;定义的形式）。\n在容器本身中，这些bean定义表示为BeanDefinition对象，其中包含（除其他信息外）以下元数据：\n  包限定的类名：通常是定义的bean的实际实现类。\n  bean行为的配置元素，它规定bean在容器中的行为（作用域、生命周期回调等）。\n  bean执行其工作时所需引用的其他bean。这些引用也称为协作者或依赖项。\n  要在新创建的对象中设置的其他配置环境 — 例如，池的大小限制或管理连接池的bean中要使用的连接数。\n  此元数据转换为组成每个bean定义的一组属性。下表介绍了这些属性：\n表1. bean定义\n   属性 解释\u0026hellip;     类 实例化bean   名称 命名bean   作用域 bean的作用域   构造函数参数 依赖注入   属性 依赖注入   自动装配模式 自动装配协作者   延迟初始化模式 延迟初始化bean   初始化方法 初始化时回调   销毁方法 销毁时回调    除了通过控制bean定义的信息来创建特定的bean之外，ApplicationContext实现还允许注册（由用户）在容器外部创建的现有对象。这是通过getBeanFactory()方法访问ApplicationContext的BeanFactory来完成的，该方法返回BeanFactory DefaultListableBeanFactory实现。DefaultListableBeanFactory支持通过registerSingleton(..)和registerBeanDefinition(..)方法注册。但是，普通的应用程序只使用通过常规bean定义元数据定义的bean。\nbean元数据和手动提供的单例实例需要尽早注册，以便容器在自动装配和其他自省步骤中正确地对它们进行推理。虽然在某种程度上支持覆盖现有元数据和现有单例实例，但官方不支持在运行时注册新bean（与对工厂的实时访问同时进行），这可能导致并发访问异常、bean容器中的状态不一致，或两者兼有。  1.3.1 命名bean #  每个bean都有一个或多个标识符。这些标识符在承载bean的容器中必须是唯一的。bean通常只有一个标识符，但是，如果需要多个，则可以将额外的标识符视为别名。\n在基于XML的配置元数据中，可以使用id属性、name属性或两者都使用来指定bean的标识符。id属性只允许您指定一个id。通常，这些名称是字母数字组成的（“myBean”，“someService”等等），但它们也可以包含特殊字符。如果要为bean引入其他别名，还可以在name属性中指定它们，并用逗号（,）或分号（;）或空格来分隔。此处有个历史上的问题需要注意，在Spring 3.1之前的版本中，id属性被定义为xsd:ID类型，它会约束可能的字符。从3.1开始，它被定义为xsd:string类型。注意，bean id唯一性仍然由容器强制执行，尽管不再由XML解析器强制执行了。\n您不需要为bean提供name或id。如果不显式提供name或id，容器将为该bean生成唯一的名称。但是，如果希望通过使用ref元素或服务定位器方式按名称引用该bean，则必须提供名称。不提供名称的内在原因与使用内部bean和自动装配协作者有关。\nbean命名约定  约定在命名bean时使用标准Java约定作为实例字段名。也就是说，bean名称以小写字母开头，然后用驼峰大小写。此类名称的示例包括accountManager、accountService、userDao、loginController等。\n命名bean会使您的配置更易于阅读和理解。此外，如果您使用Spring AOP，那么在将通知应用于一组名称相关的bean时，它会有很大帮助。\n 通过类路径中的组件扫描，Spring为未命名的组件生成bean名称，遵循前面描述的规则：本质上，采用简单的类名并将其首个字符转换为小写。但是，在（不常见的）特殊情况下，当有多个字符且第一个和第二个字符都是大写时，原始大小写将被保留。这些规则与java.beans.Introspector.decapitalize（Spring在这里使用）定义的规则相同。  在bean定义之外给bean添加别名 #  在bean定义本身中，可以为bean提供多个名称，通过使用id属性指定的最多一个名称和使用name属性指定任意数量的其他名称。这些名称可以是同一bean的等效别名，这在某些情况下非常有用，例如，可以通过使用为组件本身指定bean名称，让应用程序中的每个组件引用公共依赖项。\n但是，在实际定义bean的地方指定所有别名并不总是足够的。有时需要为在别处定义的bean引入别名。在大型系统中，配置通常在每个子系统之间分割，每个子系统都有自己的对象定义集。在基于XML的配置元数据中，您可以使用\u0026lt;alias/\u0026gt;元素来实现这一点。以下示例展示了如何执行此操作：\n\u0026lt;alias name=\u0026#34;fromName\u0026#34; alias=\u0026#34;toName\u0026#34;/\u0026gt; 在这个例子中，使用此别名定义后，名为fromName的bean（在同一容器中）也可以通过toName引用。\n例如，子系统A的配置元数据可能以subsystemA-dataSource的名称引用数据源。子系统B的配置元数据可以通过subsystemB-dataSource的名称引用数据源。在编写使用这两个子系统的主应用程序时，主应用程序以myApp-dataSource的名称引用数据源。要使所有三个名称都引用同一对象，可以将以下别名定义添加到配置元数据中：\n\u0026lt;alias name=\u0026#34;myApp-dataSource\u0026#34; alias=\u0026#34;subsystemA-dataSource\u0026#34;/\u0026gt; \u0026lt;alias name=\u0026#34;myApp-dataSource\u0026#34; alias=\u0026#34;subsystemB-dataSource\u0026#34;/\u0026gt; 现在，每个组件和主应用程序都可以通过一个唯一的名称引用数据源，并保证不会与任何其他定义冲突（有效地创建命名空间），但它们引用的是同一个bean。\nJava 配置  如果使用的是Java配置，可以用@Bean注解来设置别名。有关详细信息，请参见[@Bean注解使用]。  1.3.2 实例化bean #  bean定义本质上是创建一个或多个对象的创建方法。容器在被请求某个名字的bean时查找到该创建方法，并使用该bean定义封装的配置元数据创建（或获取）实际对象。\n如果使用基于XML的配置元数据，那么可以在\u0026lt;bean/\u0026gt;元素的class属性中指定要实例化的对象的类型（或类）。该class属性（在内部是BeanDefinition实例上的Class属性）通常是必需的(有关例外情况，请参阅通过使用实例工厂方法实例化和Bean定义继承。）您可以通过以下两种方式之一使用Class属性：\n 通常，指定要构造的bean类，然后容器本身通过反射调用其构造函数直接创建bean的场景，这在某种程度上相当于使用new操作符的Java代码。 指定包含静态工厂方法（通过调用该方法以创建对象）的实际类，在不常见的情况下，容器调用类上的静态工厂方法以创建bean。调用静态工厂方法返回的对象类型可以是同一个类，也可以是另一个类。  内部类命名\n如果要为静态嵌套类配置bean定义，则必须使用嵌套类的二进制名称。\n例如，如果在com.example包中有一个名为SomeThing的类，而这个SomeThing类中有一个名为OtherThing的静态嵌套类，那么bean定义上的class属性的值将是com.example.SomeThing$OtherThing。\n请注意，名称中使用$字符将嵌套类名与外部类名分开。\n 使用构造函数进行实例化 #  当您通过构造函数方法创建bean时，所有普通类都可以由Spring使用，并且与Spring兼容。也就是说，正在开发的类不需要实现任何特定的接口，也不需要以特定的方式进行编码。只需指定bean类就足够了。但是，根据您对特定bean使用的IoC类型，您可能需要一个默认（空）构造函数。\nSpring IoC容器实际上可以管理您希望它管理的任何类。它不仅限于管理真正的JavaBean。大多数Spring用户更喜欢真正的JavaBean，它只有一个默认（无参数）构造函数，并根据容器中的属性建模适当的setter和getter。您的容器中还可以有更多异样的非bean样式的类。例如，如果您需要使用一个完全不符合JavaBean规范的老式连接池，Spring也可以管理它。\n使用基于XML的配置元数据，您可以按如下方式指定bean类：\n\u0026lt;bean id=\u0026#34;exampleBean\u0026#34; class=\u0026#34;examples.ExampleBean\u0026#34;/\u0026gt; \u0026lt;bean name=\u0026#34;anotherExample\u0026#34; class=\u0026#34;examples.ExampleBeanTwo\u0026#34;/\u0026gt; 有关提供有参构造器（如果需要）和设置对象实例属性机制的详细信息，请参阅依赖注入。\n使用静态工厂方法进行实例化 #  定义使用静态工厂方法创建的bean时，请使用class属性指定包含静态工厂方法的类，并使用名为factory-method的属性指定工厂方法本身的名称。您应该能够调用此方法（使用可选参数，如下文所述）并返回一个有效对象，该对象随后将被视为是通过构造函数创建的。这种bean定义的一个用途是在老代码中调用静态工厂。\n下面的bean定义是通过调用指定工厂方法来创建bean的。该定义不是指定返回对象的类型（类），只是指定包含工厂方法的类。在本例中，createInstance()方法必须是静态方法。以下示例展示了如何指定工厂方法：\n\u0026lt;bean id=\u0026#34;clientService\u0026#34; class=\u0026#34;examples.ClientService\u0026#34; factory-method=\u0026#34;createInstance\u0026#34;/\u0026gt; 以下示例展示了一个使用前面的bean定义的类：\nJava public class ClientService { private static ClientService clientService = new ClientService(); private ClientService() {} public static ClientService createInstance() { return clientService; } } Kotlin class ClientService private constructor() { companion object { private val clientService = ClientService() fun createInstance() = clientService } }  有关为工厂方法提供（可选）参数和从工厂返回对象后设置对象实例属性机制的详细信息，请参阅依赖项和配置。\n使用实例工厂方法进行实例化 #  与通过静态工厂方法的实例化类似，使用实例工厂方法的实例化是从容器中调用现有bean的非静态方法来创建新bean。要使用此机制，请将class属性设置为空，并在factory-bean属性中指定当前（或父级或祖先级）容器中的bean名称，该容器包含要调用以创建对象的实例方法。使用factory-method属性设置工厂方法本身的名称。下面的示例演示了如何配置这样的bean：\n\u0026lt;!-- 工厂bean，包含一个名为createInstance()的方法（注，此处的createInstance()指“创建实例”的方法） --\u0026gt; \u0026lt;bean id=\u0026#34;serviceLocator\u0026#34; class=\u0026#34;examples.DefaultServiceLocator\u0026#34;\u0026gt; \u0026lt;!-- 注入此定位器bean所需的任何依赖项 --\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!-- 要通过工厂bean创建的bean --\u0026gt; \u0026lt;bean id=\u0026#34;clientService\u0026#34; factory-bean=\u0026#34;serviceLocator\u0026#34; factory-method=\u0026#34;createClientServiceInstance\u0026#34;/\u0026gt; 以下示例展示了相应的类：\nJava public class DefaultServiceLocator { private static ClientService clientService = new ClientServiceImpl(); public ClientService createClientServiceInstance() { return clientService; } } Kotlin class DefaultServiceLocator { companion object { private val clientService = ClientServiceImpl() } fun createClientServiceInstance(): ClientService { return clientService } }  一个工厂类还可以包含多个工厂方法，如下例所示：\n\u0026lt;bean id=\u0026#34;serviceLocator\u0026#34; class=\u0026#34;examples.DefaultServiceLocator\u0026#34;\u0026gt; \u0026lt;!-- 注入此定位器bean所需的任何依赖项 --\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;clientService\u0026#34; factory-bean=\u0026#34;serviceLocator\u0026#34; factory-method=\u0026#34;createClientServiceInstance\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;accountService\u0026#34; factory-bean=\u0026#34;serviceLocator\u0026#34; factory-method=\u0026#34;createAccountServiceInstance\u0026#34;/\u0026gt; 以下示例展示了相应的类：\nJava public class DefaultServiceLocator { private static ClientService clientService = new ClientServiceImpl(); private static AccountService accountService = new AccountServiceImpl(); public ClientService createClientServiceInstance() { return clientService; } public AccountService createAccountServiceInstance() { return accountService; } } Kotlin class DefaultServiceLocator { companion object { private val clientService = ClientServiceImpl() private val accountService = AccountServiceImpl() } fun createClientServiceInstance(): ClientService { return clientService } fun createAccountServiceInstance(): AccountService { return accountService } }  这种方法表明，工厂bean本身可以通过依赖注入（DI）进行管理和配置。详情请查看依赖项和配置。\n在Spring文档中，“工厂bean”（“factory bean”）是指在Spring容器中配置的bean，它通过实例或静态工厂方法创建对象。相比之下，FactoryBean（注意大写）指的是Spring特定的FactoryBean。  "},{"id":6,"href":"/spring-doc/testing/","title":"测试","section":"Spring框架文档","content":"测试 #  Version 5.2.2.RELEASE\n "},{"id":7,"href":"/spring-doc/core/beans/beans-dependencies/","title":"1.4 依赖","section":"1. IoC容器","content":"1.4 依赖 #  Version 5.2.2.RELEASE\n 典型的企业应用程序不会仅由单个对象（或Spring术语中的bean）组成的。即使是最简单的应用程序，也有几个对象一起工作，以让最终用户感觉是协调一致的应用程序。下一节将解释如何从定义大量独立的bean定义过渡到一个完全实现的应用程序，在这个应用程序中，对象相互协作以实现一个目标。\n1.4.1 依赖注入 #  依赖注入（DI）是一个过程，对象仅通过构造函数参数、工厂方法的参数或在对象实例构造或从工厂方法返回后在对象实例上设置的属性来定义其依赖项（即与之一起工作的其他对象）。然后，容器在创建bean时注入这些依赖项。这个过程基本上与bean本身通过使用类直接构造或服务定位器模式来控制其依赖项的实例化或位置相反（因此称为控制反转）。\n使用DI原理，代码更干净，当对象具有依赖关系时，解耦更有效。对象不查找其依赖项，也不知道依赖项的位置或类。因此，您的类变得更容易测试，特别是当依赖项位于接口或抽象基类上时，这允许在单元测试中使用存根或模拟实现。\nDI有两种主要变体：基于构造函数的依赖注入和基于Setter的依赖注入。\n基于构造函数的依赖注入 #  基于构造函数的DI是通过容器调用具有多个参数的构造函数来完成的，每个参数表示一个依赖项。调用带有特定参数的静态工厂方法来构造bean几乎是相同的，在此探讨中对待构造函数和静态工厂方法的参数是类似的。以下示例展示了一个类，该类只通过构造函数注入来实现依赖项注入：\nJava public class SimpleMovieLister { // SimpleMovieLister有一个依赖项：MovieFinder  private MovieFinder movieFinder; // 该构造器使得Spring容器可以注入一个MovieFinder  public SimpleMovieLister(MovieFinder movieFinder) { this.movieFinder = movieFinder; } // 此处省略了实际使用注入的MovieFinder的业务逻辑 } Kotlin // 该构造器使得Spring容器可以注入一个MovieFinder class SimpleMovieLister(private val movieFinder: MovieFinder) { // 此处省略了实际使用注入的MovieFinder的业务逻辑 }  请注意，这个类没有什么特别之处。它就是是一个POJO，不依赖于容器特定的接口、基类或注解。\n构造函数参数解析 #  构造函数参数解析是通过使用参数的类型进行匹配的。如果bean定义的构造函数参数中不存在潜在的歧义，那么在bean定义中定义构造函数参数的顺序就是在实例化bean时将这些参数提供给相应构造函数的顺序。考虑下面的类：\nJava package x.y; public class ThingOne { public ThingOne(ThingTwo thingTwo, ThingThree thingThree) { // ...  } } Kotlin package x.y class ThingOne(thingTwo: ThingTwo, thingThree: ThingThree)  假设ThingTwo和ThingTree类没有继承关系，则不存在潜在的歧义。因此，以下配置可以正常工作，您不需要在\u0026lt;constructor arg/\u0026gt;元素中显式指定构造函数参数索引或类型。\n\u0026lt;beans\u0026gt; \u0026lt;bean id=\u0026#34;beanOne\u0026#34; class=\u0026#34;x.y.ThingOne\u0026#34;\u0026gt; \u0026lt;constructor-arg ref=\u0026#34;beanTwo\u0026#34;/\u0026gt; \u0026lt;constructor-arg ref=\u0026#34;beanThree\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;beanTwo\u0026#34; class=\u0026#34;x.y.ThingTwo\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;beanThree\u0026#34; class=\u0026#34;x.y.ThingThree\u0026#34;/\u0026gt; \u0026lt;/beans\u0026gt; 当引用另一个bean时，类型已知，并且可以进行匹配（如前一个示例所示）。使用简单类型时，例如\u0026lt;value\u0026gt;true\u0026lt;/value\u0026gt;，Spring无法确定值的类型，因此在没有帮助的情况下无法按类型进行匹配。考虑下面的类：\nJava package examples; public class ExampleBean { // Number of years to calculate the Ultimate Answer  private int years; // The Answer to Life, the Universe, and Everything  private String ultimateAnswer; public ExampleBean(int years, String ultimateAnswer) { this.years = years; this.ultimateAnswer = ultimateAnswer; } } Kotlin package examples class ExampleBean( private val years: Int, // Number of years to calculate the Ultimate Answer  private val ultimateAnswer: String// The Answer to Life, the Universe, and Everything )  构造函数参数类型匹配\n在前面的场景中，如果使用type属性显式指定构造函数参数的类型，则容器可以使用简单类型的类型匹配。如下例所示：\n\u0026lt;bean id=\u0026#34;exampleBean\u0026#34; class=\u0026#34;examples.ExampleBean\u0026#34;\u0026gt; \u0026lt;constructor-arg type=\u0026#34;int\u0026#34; value=\u0026#34;7500000\u0026#34;/\u0026gt; \u0026lt;constructor-arg type=\u0026#34;java.lang.String\u0026#34; value=\u0026#34;42\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; 构造函数参数索引\n可以使用index属性显式指定构造函数参数的索引，如下例所示：\n\u0026lt;bean id=\u0026#34;exampleBean\u0026#34; class=\u0026#34;examples.ExampleBean\u0026#34;\u0026gt; \u0026lt;constructor-arg index=\u0026#34;0\u0026#34; value=\u0026#34;7500000\u0026#34;/\u0026gt; \u0026lt;constructor-arg index=\u0026#34;1\u0026#34; value=\u0026#34;42\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; 除了解决多个简单值的歧义外，如果构造函数有两个相同类型的参数，则指定索引也可以解决歧义。\n该索引是从0开始的。  构造函数参数名\n您还可以使用构造函数参数名称来消除值的歧义，如下例所示：\n\u0026lt;bean id=\u0026#34;exampleBean\u0026#34; class=\u0026#34;examples.ExampleBean\u0026#34;\u0026gt; \u0026lt;constructor-arg name=\u0026#34;years\u0026#34; value=\u0026#34;7500000\u0026#34;/\u0026gt; \u0026lt;constructor-arg name=\u0026#34;ultimateAnswer\u0026#34; value=\u0026#34;42\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; 请记住，要使这种方式开箱即用，必须在编译代码时启用调试标志，以便Spring可以从构造函数中查找参数名。如果不能或不想使用调试标志编译代码，可以使用@ConstructorProperties JDK注解显式命名构造函数参数。然后，示例类必须如下所示：\nJava package examples; public class ExampleBean { // Fields omitted  @ConstructorProperties({\u0026#34;years\u0026#34;, \u0026#34;ultimateAnswer\u0026#34;}) public ExampleBean(int years, String ultimateAnswer) { this.years = years; this.ultimateAnswer = ultimateAnswer; } } Kotlin package examples class ExampleBean @ConstructorProperties(\u0026#34;years\u0026#34;, \u0026#34;ultimateAnswer\u0026#34;) constructor(val years: Int, val ultimateAnswer: String)  基于setter的依赖注入 #  基于setter的DI是由容器在调用无参构造函数或无参静态工厂方法实例化bean之后，在bean上调用setter方法来完成的。\n下面的示例展示了一个只能使用纯setter注入进行依赖注入的类。这个类是传统的Java类。它是一个POJO，不依赖于容器特定的接口、基类或注解。\nJava public class SimpleMovieLister { // SimpleMovieLister依赖于MovieFinder  private MovieFinder movieFinder; // 此setter方法可以使Spring容器注入MovieFinder  public void setMovieFinder(MovieFinder movieFinder) { this.movieFinder = movieFinder; } // 省略了实际使用注入的MovieFinder的业务逻辑 } Kotlin class SimpleMovieLister { // 这是一个延迟初始化的属性，可以使Spring容器注入MovieFinder  lateinit var movieFinder: MovieFinder // 省略了实际使用注入的MovieFinder的业务逻辑 }  ApplicationContext为其管理的bean支持基于构造函数和基于setter的DI。在通过构造函数方法注入一些依赖项之后，它还支持使用基于setter的DI再注入一些依赖项。您可以以BeanDefinition的形式配置依赖项，将其与PropertyEditor实例一起使用，以将属性从一种格式转换为另一种格式。然而，大多数Spring用户并不直接使用这些类（即编程），而是使用XML bean定义、带注解的组件（即用@Component、@Controller等注解标注的类）或基于Java的@Configuration类中的@Bean方法。然后，这些源在内部转换为BeanDefinition的实例，并用于加载整个Spring IoC容器实例。\n基于构造函数的DI还是基于setter的DI？  因为您可以混合使用基于构造函数和基于setter的依赖注入，所以使用构造函数注入强制依赖项，使用setter方法或配置方法注入可选依赖项，这是一个很好的经验法则。注意，在setter方法上使用@Required注解可以使属性成为必需的依赖项；但是，最好在构造函数注入时使用编程的方式验证参数。\nSpring团队通常提倡构造函数注入，因为它允许您将应用程序组件实现为不可变对象，并确保所需的依赖项不为null。此外，构造函数注入的组件总是以完全初始化的状态返回给客户端代码（调用）。顺便说一下，构造函数存在大量参数是一种糟糕的代码味道，这意味着此类可能有太多的责任，应该进行重构以更好地对关注点进行分离。\nsetter注入应该主要用于可选的依赖项，这些依赖项可以在类中分配合理的默认值。否则，必须在代码使用依赖项的任何地方执行非空检查。setter注入的一个好处是setter方法使该类的对象易于以后重新配置或重新注入。因此，通过JMX MBeans进行管理是setter注入的一个引人注目的案例。\n使用对特定类最有意义的依赖方式。有时，在处理您没有源代码的第三方类时，您可以做出选择。例如，如果第三方类不公开任何setter方法，那么构造函数注入可能是唯一可用的依赖注入方式。\n 依赖项解析过程 #  容器执行bean依赖项解析，如下所示：\n ApplicationContext是用描述所有bean的配置元数据创建和初始化的。配置元数据可以由XML、Java代码或注解指定。 对于每个bean，其依赖项都以属性、构造函数参数或静态工厂方法参数（如果您使用静态工厂方法而不是普通构造函数）的形式提供。这些依赖关系在bean被实际创建时提供给bean。 每个属性或构造函数参数都是要设置的值的实际定义，或者是对容器中另一个bean的引用。 每个属性或构造函数参数的值都将从其指定格式转换为该属性或构造函数参数的实际类型。默认情况下，Spring可以将以字符串格式提供的值转换为所有内置类型，例如int、long、String、boolean等。  Spring容器在创建容器时验证每个bean的配置。但是，在实际创建bean之前，不会设置bean的属性本身。创建容器时，将创建单例作用域并设置为预实例化（默认）的bean。作用域是在bean的作用域中定义的。否则，只有在请求时才创建bean。创建bean可能会导致创建bean图，因为bean的依赖项及其依赖项的依赖项（等等）是要被创建和被分配的。请注意，这些依赖项之间的解析不匹配可能会延迟暴露 — 也就是说，在第一次创建受影响的bean时才暴露。\n循环依赖  如果主要使用构造函数注入，则有可能创建无法解决的循环依赖场景。\n例如：类A通过构造函数注入需要类B的实例，类B通过构造函数注入需要类A的实例。如果为类A和类B配置bean以相互注入，Spring IoC容器将在运行时检测到此循环引用，并抛出BeanCurrentlyInCreationException。\n一种可能的解决方案是编辑某些类的源代码，由setter而不是构造函数进行配置。或者，避免构造函数注入，只使用setter注入。换句话说，虽然不建议使用setter注入，但您可以使用setter注入来配置循环依赖项。\n与常见情况（没有循环依赖）不同，bean A和bean B之间的循环依赖迫使一个bean在完全初始化之前注入另一个bean（典型的先有鸡还是先有蛋的场景）。\n 您通常可以相信Spring会做正确的事情。它在容器加载时检测配置问题，例如对不存在的bean的引用和循环依赖项。Spring在bean实际创建时尽可能晚地设置属性并解析依赖项。这意味着，如果创建该对象或其依赖项之一时出现问题（例如，bean由于缺少或无效属性而引发异常），则已正确加载的 Spring 容器稍后可以在您请求该对象时生成异常。这可能会延迟某些配置问题的可见性，这就是ApplicationContext实现在默认情况下预先实例化单例bean的原因。在实际需要这些bean之前，您需要花费一些前期时间和内存来创建它们，但在创建ApplicationContext时（而不是以后）会发现配置问题。您仍然可以覆盖此默认行为，以便单例bean延迟初始化，而不是预先实例化。\n如果不存在循环依赖关系，那么当一个或多个协作bean被注入到依赖bean中时，每个协作bean在被注入到依赖bean中之前都会被完全配置。这意味着，如果bean A依赖于bean B，那么Spring IoC容器将在调用bean A上的setter方法之前完全配置完bean B。换句话说，bean被实例化了（如果它不是预实例化的单例），则它的依赖项会被设置，相关的生命周期方法（例如配置的init方法或InitializingBean回调方法）也会被调用。\n依赖注入示例 #  以下示例将基于XML的配置元数据使用setter方式进行依赖注入。Spring XML配置文件的一小部分指定了一些bean定义，如下所示：\n\u0026lt;bean id=\u0026#34;exampleBean\u0026#34; class=\u0026#34;examples.ExampleBean\u0026#34;\u0026gt; \u0026lt;!-- 使用嵌套ref元素的setter注入 --\u0026gt; \u0026lt;property name=\u0026#34;beanOne\u0026#34;\u0026gt; \u0026lt;ref bean=\u0026#34;anotherExampleBean\u0026#34;/\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;!-- 使用整洁ref属性的setter注入 --\u0026gt; \u0026lt;property name=\u0026#34;beanTwo\u0026#34; ref=\u0026#34;yetAnotherBean\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;integerProperty\u0026#34; value=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;anotherExampleBean\u0026#34; class=\u0026#34;examples.AnotherBean\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;yetAnotherBean\u0026#34; class=\u0026#34;examples.YetAnotherBean\u0026#34;/\u0026gt; 以下示例展示了相应的ExampleBean类：\nJava public class ExampleBean { private AnotherBean beanOne; private YetAnotherBean beanTwo; private int i; public void setBeanOne(AnotherBean beanOne) { this.beanOne = beanOne; } public void setBeanTwo(YetAnotherBean beanTwo) { this.beanTwo = beanTwo; } public void setIntegerProperty(int i) { this.i = i; } } Kotlin class ExampleBean { lateinit var beanOne: AnotherBean lateinit var beanTwo: YetAnotherBean var i: Int = 0 }  在前面的示例中，setter被声明为与XML文件中指定的属性相匹配。以下示例使用基于构造函数的依赖注入：\n\u0026lt;bean id=\u0026#34;exampleBean\u0026#34; class=\u0026#34;examples.ExampleBean\u0026#34;\u0026gt; \u0026lt;!-- 使用嵌套ref元素的构造函数注入 --\u0026gt; \u0026lt;constructor-arg\u0026gt; \u0026lt;ref bean=\u0026#34;anotherExampleBean\u0026#34;/\u0026gt; \u0026lt;/constructor-arg\u0026gt; \u0026lt;!-- 使用整洁的ref属性的构造函数注入 --\u0026gt; \u0026lt;constructor-arg ref=\u0026#34;yetAnotherBean\u0026#34;/\u0026gt; \u0026lt;constructor-arg type=\u0026#34;int\u0026#34; value=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;anotherExampleBean\u0026#34; class=\u0026#34;examples.AnotherBean\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;yetAnotherBean\u0026#34; class=\u0026#34;examples.YetAnotherBean\u0026#34;/\u0026gt; 以下示例展示了相应的ExampleBean类：\nJava public class ExampleBean { private AnotherBean beanOne; private YetAnotherBean beanTwo; private int i; public ExampleBean( AnotherBean anotherBean, YetAnotherBean yetAnotherBean, int i) { this.beanOne = anotherBean; this.beanTwo = yetAnotherBean; this.i = i; } } Kotlin class ExampleBean( private val beanOne: AnotherBean, private val beanTwo: YetAnotherBean, private val i: Int)  bean定义中指定的构造函数参数用作ExampleBean构造函数的参数。\n现在考虑这个例子的一个变体，在这里，Spring被告知调用静态工厂方法来返回对象的实例，而不是使用构造函数：\n\u0026lt;bean id=\u0026#34;exampleBean\u0026#34; class=\u0026#34;examples.ExampleBean\u0026#34; factory-method=\u0026#34;createInstance\u0026#34;\u0026gt; \u0026lt;constructor-arg ref=\u0026#34;anotherExampleBean\u0026#34;/\u0026gt; \u0026lt;constructor-arg ref=\u0026#34;yetAnotherBean\u0026#34;/\u0026gt; \u0026lt;constructor-arg value=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;anotherExampleBean\u0026#34; class=\u0026#34;examples.AnotherBean\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;yetAnotherBean\u0026#34; class=\u0026#34;examples.YetAnotherBean\u0026#34;/\u0026gt; 以下示例展示了相应的ExampleBean类：\nJava public class ExampleBean { // 私有的构造函数  private ExampleBean(...) { ... } // 静态工厂法；此方法的参数可以被视为要返回的bean的依赖项，而不管这些参数实际如何使用。  public static ExampleBean createInstance ( AnotherBean anotherBean, YetAnotherBean yetAnotherBean, int i) { ExampleBean eb = new ExampleBean (...); // 其他操作...  return eb; } } Kotlin class ExampleBean private constructor() { companion object { // 静态工厂法；此方法的参数可以被视为要返回的bean的依赖项，而不管这些参数实际如何使用。  fun createInstance(anotherBean: AnotherBean, yetAnotherBean: YetAnotherBean, i: Int): ExampleBean { val eb = ExampleBean (...) // 其他操作...  return eb } } }  静态工厂方法的参数由\u0026lt;constructor-arg/\u0026gt;元素提供，与实际使用的构造函数完全相同。工厂方法返回的类的类型不必与包含静态工厂方法的类的类型相同（尽管在本例中是相同的）。实例（非静态）工厂方法可以以基本相同的方式使用（除了使用factory-bean属性而不是class属性之外），因此我们这里不讨论这些细节。\n1.4.2 详细的依赖项和配置 #  如前一节所述，您可以将bean属性和构造函数参数定义为对其他bean（协作者）的引用或内联定义的值。为此，Spring基于XML的配置元数据支持其\u0026lt;property/\u0026gt;和\u0026lt;constructor-arg/\u0026gt;元素中使用子元素类型。\n直接的值（基本类型、字符串等等） #  \u0026lt;property/\u0026gt;元素的value属性将属性或构造函数参数指定为人可读字符串的表示形式。Spring的转换服务用于将这些值从字符串转换为属性或参数的实际类型。以下示例显示了正在设置的各种值：\n\u0026lt;bean id=\u0026#34;myDataSource\u0026#34; class=\u0026#34;org.apache.commons.dbcp.BasicDataSource\u0026#34; destroy-method=\u0026#34;close\u0026#34;\u0026gt; \u0026lt;!-- 调用setDriverClassName(String) --\u0026gt; \u0026lt;property name=\u0026#34;driverClassName\u0026#34; value=\u0026#34;com.mysql.jdbc.Driver\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;jdbc:mysql://localhost:3306/mydb\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;masterkaoli\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; 以下示例使用p命名空间进行更简洁的XML配置：\n\u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:p=\u0026#34;http://www.springframework.org/schema/p\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;myDataSource\u0026#34; class=\u0026#34;org.apache.commons.dbcp.BasicDataSource\u0026#34; destroy-method=\u0026#34;close\u0026#34; p:driverClassName=\u0026#34;com.mysql.jdbc.Driver\u0026#34; p:url=\u0026#34;jdbc:mysql://localhost:3306/mydb\u0026#34; p:username=\u0026#34;root\u0026#34; p:password=\u0026#34;masterkaoli\u0026#34;/\u0026gt; \u0026lt;/beans\u0026gt; 前面的XML更简洁。但是，输入错误是在运行时而不是在设计时发现的，除非您在创建bean定义时使用支持自动属性补全的IDE（如IntelliJ IDEA或Spring Tool Suite）。强烈建议使用此类IDE帮助。\n您还可以配置java.util.Properties实例，如下所示：\n\u0026lt;bean id=\u0026#34;mappings\u0026#34; class=\u0026#34;org.springframework.context.support.PropertySourcesPlaceholderConfigurer\u0026#34;\u0026gt; \u0026lt;!-- 类型为 java.util.Properties --\u0026gt; \u0026lt;property name=\u0026#34;properties\u0026#34;\u0026gt; \u0026lt;value\u0026gt; jdbc.driver.className=com.mysql.jdbc.Driver jdbc.url=jdbc:mysql://localhost:3306/mydb \u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; Spring容器使用JavaBeans PropertyEditor机制将\u0026lt;value/\u0026gt;元素中的文本转换为java.util.Properties实例。这是一个很好的捷径，也是Spring团队喜欢使用嵌套的\u0026lt;value/\u0026gt;元素而不是value属性样式的几个地方之一。\nidref元素 #  idref元素只是一种防错误的方法，用于将容器中另一个bean的id（字符串的值，不是引用）传递给\u0026lt;constructor-arg/\u0026gt;或\u0026lt;property/\u0026gt;元素。以下示例展示了如何使用它：\n\u0026lt;bean id=\u0026#34;theTargetBean\u0026#34; class=\u0026#34;...\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;theClientBean\u0026#34; class=\u0026#34;...\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;targetName\u0026#34;\u0026gt; \u0026lt;idref bean=\u0026#34;theTargetBean\u0026#34;/\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; 前面的bean定义片段（在运行时）与下面的片段完全等效：\n\u0026lt;bean id=\u0026#34;theTargetBean\u0026#34; class=\u0026#34;...\u0026#34; /\u0026gt; \u0026lt;bean id=\u0026#34;client\u0026#34; class=\u0026#34;...\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;targetName\u0026#34; value=\u0026#34;theTargetBean\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; 第一种形式比第二种形式更可取，因为使用idref标记可以让容器在部署时验证引用的bean是否确实存在。在第二种形式中，没有对传递给client bean的targetName属性的值执行任何验证。只有在实际实例化client bean时才会发现输入错误（很可能是致命的结果）。如果client bean是一个原型bean，那么只有在部署容器后很长一段时间才能发现这个输入错误和由此产生的异常。\nidref元素上的local属性在4.0 beans XSD中不再受支持，因为它不再提供常规bean引用上的值。升级到4.0架构时，需要将现有的idref local引用更改为idref bean。  \u0026lt;idref/\u0026gt;元素带来价值的一个常见位置（至少在Spring 2.0之前的版本中）是ProxyFactoryBean bean定义中的AOP拦截器配置。在指定拦截器名称时使用\u0026lt;idref/\u0026gt;元素可以防止拼写拦截器ID错误。\n对其他bean（协作者）的引用 #  ref元素是\u0026lt;constructor-arg/\u0026gt;或\u0026lt;property/\u0026gt;定义元素中的最后一个元素。这里，您将bean的指定属性的值设置为容器管理的另一个bean（协作者）的引用。被引用的bean是要被设置属性bean的依赖项，并且在设置属性之前根据需要对其进行初始化(如果协作者是单例bean，它可能已经被容器初始化。）所有引用最终都是对另一个对象的引用。作用域和验证取决于是否通过bean、local或parent属性指定其他对象的ID或名称。\n通过\u0026lt;ref/\u0026gt;标记的bean属性来指定目标bean是最常见的方式，它允许创建对同一容器或父容器中任何bean的引用，而不管它们是否在同一XML文件中。bean属性的值可以与目标bean的id属性相同，或者与目标bean的name属性中的一个值相同。以下示例显示了如何使用ref元素：\n\u0026lt;ref bean=\u0026#34;someBean\u0026#34;/\u0026gt; 通过parent属性指定目标bean将创建对当前容器的父容器中的bean的引用。parent属性的值可以与目标bean的id属性或目标bean的name属性中的一个值相同。目标bean必须位于当前bean的父容器中。使用这个bean引用变量，主要场景应该是当容器有层次结构，并且希望使用与父bean同名的代理来将现有bean包装到父容器中时。以下展示示了如何使用parent属性：\n\u0026lt;!-- 在父上下文中 --\u0026gt; \u0026lt;bean id=\u0026#34;accountService\u0026#34; class=\u0026#34;com.something.SimpleAccountService\u0026#34;\u0026gt; \u0026lt;!-- 根据需要在此处插入依赖项 --\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!-- 在子（后代）上下文中 --\u0026gt; \u0026lt;bean id=\u0026#34;accountService\u0026#34; \u0026lt;!-- bean名称与父bean相同 --\u0026gt; class=\u0026#34;org.springframework.aop.framework.ProxyFactoryBean\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;target\u0026#34;\u0026gt; \u0026lt;ref parent=\u0026#34;accountService\u0026#34;/\u0026gt; \u0026lt;!-- 注意我们如何引用父bean --\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;!-- 根据需要在此处插入其他配置和依赖项 --\u0026gt; \u0026lt;/bean\u0026gt; ref元素上的local属性在4.0 bean XSD中不再受支持，因为它不再提供常规bean引用上的值。升级到4.0时，请将现有的ref local引用更改为ref bean。  内部bean #  \u0026lt;property/\u0026gt;或\u0026lt;constructor-arg/\u0026gt;元素中的\u0026lt;bean/\u0026gt;元素定义内部bean，如下例所示：\n\u0026lt;bean id=\u0026#34;outer\u0026#34; class=\u0026#34;...\u0026#34;\u0026gt; \u0026lt;!-- 不使用对目标bean的引用，只需内联定义目标bean --\u0026gt; \u0026lt;property name=\u0026#34;target\u0026#34;\u0026gt; \u0026lt;bean class=\u0026#34;com.example.Person\u0026#34;\u0026gt; \u0026lt;!-- 这就是内部bean --\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;Fiona Apple\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;age\u0026#34; value=\u0026#34;25\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; 内部bean定义不需要定义ID或名称。即使指定了，容器也不使用此类值作为标识符。容器在创建时也会忽略scope标志，因为内部bean总是匿名的，并且总是使用外部bean创建的。不能单独访问内部bean，也不能将它们注入到协作bean而不是封闭bean中。\n作为一种特殊情况，内部bean可以从自定义范围接收销毁回调 — 例如，对于单例bean中包含的请求范围的内部bean。内部bean实例的创建与其包含的bean相关联，但销毁回调允许它参与请求范围的生命周期。这不是常见的情况。内部bean通常只是共享其包含bean的范围。\n集合 #  \u0026lt;list/\u0026gt;、\u0026lt;set/\u0026gt;、\u0026lt;map/\u0026gt;和\u0026lt;props/\u0026gt;元素分别设置Java集合类型List、Set、Map和Properties的属性和参数。以下示例展示了如何使用它们：\n\u0026lt;bean id=\u0026#34;moreComplexObject\u0026#34; class=\u0026#34;example.ComplexObject\u0026#34;\u0026gt; \u0026lt;!-- 调用setAdminEmails(java.util.Properties) --\u0026gt; \u0026lt;property name=\u0026#34;adminEmails\u0026#34;\u0026gt; \u0026lt;props\u0026gt; \u0026lt;prop key=\u0026#34;administrator\u0026#34;\u0026gt;administrator@example.org\u0026lt;/prop\u0026gt; \u0026lt;prop key=\u0026#34;support\u0026#34;\u0026gt;support@example.org\u0026lt;/prop\u0026gt; \u0026lt;prop key=\u0026#34;development\u0026#34;\u0026gt;development@example.org\u0026lt;/prop\u0026gt; \u0026lt;/props\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;!-- 调用setSomeList(java.util.List) --\u0026gt; \u0026lt;property name=\u0026#34;someList\u0026#34;\u0026gt; \u0026lt;list\u0026gt; \u0026lt;value\u0026gt;a list element followed by a reference\u0026lt;/value\u0026gt; \u0026lt;ref bean=\u0026#34;myDataSource\u0026#34; /\u0026gt; \u0026lt;/list\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;!-- 调用setSomeMap(java.util.Map) --\u0026gt; \u0026lt;property name=\u0026#34;someMap\u0026#34;\u0026gt; \u0026lt;map\u0026gt; \u0026lt;entry key=\u0026#34;an entry\u0026#34; value=\u0026#34;just some string\u0026#34;/\u0026gt; \u0026lt;entry key =\u0026#34;a ref\u0026#34; value-ref=\u0026#34;myDataSource\u0026#34;/\u0026gt; \u0026lt;/map\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;!-- 调用setSomeSet(java.util.Set) --\u0026gt; \u0026lt;property name=\u0026#34;someSet\u0026#34;\u0026gt; \u0026lt;set\u0026gt; \u0026lt;value\u0026gt;just some string\u0026lt;/value\u0026gt; \u0026lt;ref bean=\u0026#34;myDataSource\u0026#34; /\u0026gt; \u0026lt;/set\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; map的key或value的值或集合的值也可以是以下任意元素：\nbean | ref | idref | list | set | map | props | value | null 集合合并 #  Spring容器还支持合并集合。应用程序的开发人员可以定义父级\u0026lt;list/\u0026gt;、\u0026lt;map/\u0026gt;、\u0026lt;set/\u0026gt;或\u0026lt;props/\u0026gt;元素，并让子级\u0026lt;list/\u0026gt;、\u0026lt;map/\u0026gt;、\u0026lt;set/\u0026gt;或\u0026lt;props/\u0026gt;元素继承和重写父集合中的值。也就是说，子集合的值是父集合和子集合的元素合并的结果，子集合的元素覆盖父集合中指定的值。\n关于合并的这一节讨论父子bean机制。不熟悉父bean和子bean定义的读者可能希望在继续往下之前阅读相关部分。\n以下示例演示了集合合并：\n\u0026lt;beans\u0026gt; \u0026lt;bean id=\u0026#34;parent\u0026#34; abstract=\u0026#34;true\u0026#34; class=\u0026#34;example.ComplexObject\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;adminEmails\u0026#34;\u0026gt; \u0026lt;props\u0026gt; \u0026lt;prop key=\u0026#34;administrator\u0026#34;\u0026gt;administrator@example.com\u0026lt;/prop\u0026gt; \u0026lt;prop key=\u0026#34;support\u0026#34;\u0026gt;support@example.com\u0026lt;/prop\u0026gt; \u0026lt;/props\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;child\u0026#34; parent=\u0026#34;parent\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;adminEmails\u0026#34;\u0026gt; \u0026lt;!-- 合并是在子集合定义上指定的 --\u0026gt; \u0026lt;props merge=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;prop key=\u0026#34;sales\u0026#34;\u0026gt;sales@example.com\u0026lt;/prop\u0026gt; \u0026lt;prop key=\u0026#34;support\u0026#34;\u0026gt;support@example.co.uk\u0026lt;/prop\u0026gt; \u0026lt;/props\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;beans\u0026gt; 注意在child bean定义的adminEmails属性的\u0026lt;props/\u0026gt;元素上使用了merge=true属性。当容器解析并实例化child bean时，生成的实例具有一个adminEmails Properties的集合，该集合包含将子bean的adminEmails集合与父bean的adminEmails集合合并的结果。下面的列表显示了结果：\nadministrator=administrator@example.com sales=sales@example.com support=support@example.co.uk 子Properties集合的值继承父级\u0026lt;props/\u0026gt;的所有属性元素，并且子级中support的值覆盖父级集合中的support值。\n此合并行为类似于\u0026lt;list/\u0026gt;、\u0026lt;map/\u0026gt;和\u0026lt;set/\u0026gt;集合类型。\u0026lt;list/\u0026gt;元素在特定情况下，与List集合类型（即值的有序集合的概念）相关联的行为将得到保持。父列表的值位于子列表的所有值之前。对于Map、Set和Properties集合类型，不存在排序。因此，对于容器内部使用的关联Map、Set和Properties实现类型的基础集合类型，没有有效的排序语义。\n集合合并的局限性 #  不能合并不同的集合类型（例如Map和List）。如果真的尝试这样做，则会引发相应的异常。必须在较低的继承子定义上指定merge属性。在父集合定义上指定merge属性是多余的，不会导致所需的合并。\n强类型集合 #  随着Java5中泛型类型的引入，您可以使用强类型集合。也就是说，可以声明Collection类型，使其只能包含（例如）String元素。如果使用Spring将强类型Collection注入bean中，则可以利用Spring的类型转换支持，以便在将强类型Collection实例的元素添加到集合之前将其转换为适当的类型。以下Java类和bean定义说明了如何执行此操作：\nJava public class SomeClass { private Map\u0026lt;String, Float\u0026gt; accounts; public void setAccounts(Map\u0026lt;String, Float\u0026gt; accounts) { this.accounts = accounts; } } Kotlin class SomeClass { lateinit var accounts: Map\u0026lt;String, Float\u0026gt; }  \u0026lt;beans\u0026gt; \u0026lt;bean id=\u0026#34;something\u0026#34; class=\u0026#34;x.y.SomeClass\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;accounts\u0026#34;\u0026gt; \u0026lt;map\u0026gt; \u0026lt;entry key=\u0026#34;one\u0026#34; value=\u0026#34;9.99\u0026#34;/\u0026gt; \u0026lt;entry key=\u0026#34;two\u0026#34; value=\u0026#34;2.75\u0026#34;/\u0026gt; \u0026lt;entry key=\u0026#34;six\u0026#34; value=\u0026#34;3.99\u0026#34;/\u0026gt; \u0026lt;/map\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 当something bean的accounts属性准备好注入时，强类型Map\u0026lt;String, Float\u0026gt;的元素类型的泛型信息可以通过反射获得。因此，Spring的类型转换基础设施将各种值元素识别为Float类型，字符串值（9.99、2.75和3.99）被转换为实际的Float类型。\nnull和空字符串值 #  Spring将属性的空参数视为空字符串。以下基于XML的配置元数据片段将属性email设置为空字符串值（\u0026quot;\u0026quot;）。\n\u0026lt;bean class=\u0026#34;ExampleBean\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;email\u0026#34; value=\u0026#34;\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; 前面的示例相当于以下Java代码：\nJava exampleBean.setEmail(\u0026#34;\u0026#34;); Kotlin exampleBean.email = \u0026#34;\u0026#34;  \u0026lt;null/\u0026gt;元素用于处理空值。下面的列表展示了一个示例：\n\u0026lt;bean class=\u0026#34;ExampleBean\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;email\u0026#34;\u0026gt; \u0026lt;null/\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; 上述配置相当于以下Java代码：\nJava exampleBean.setEmail(null); Kotlin exampleBean.email = null  使用p-命名空间的XML快捷方式 #  p-命名空间允许您使用bean元素的属性（而不是嵌套的\u0026lt;property/\u0026gt;元素）来描述您的属性值、协作bean，或者两者都有。\nSpring支持带有命名空间的可扩展配置格式，这些命名空间基于XML模式定义。本章讨论的beans配置格式在XML模式文档中定义。但是，p-命名空间没有在XSD文件中定义，只存在于Spring核心中。\n以下示例展示了两个解析为相同结果的XML片段（第一个使用标准XML格式，第二个使用p命名空间）：\n\u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:p=\u0026#34;http://www.springframework.org/schema/p\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;bean name=\u0026#34;classic\u0026#34; class=\u0026#34;com.example.ExampleBean\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;email\u0026#34; value=\u0026#34;someone@somewhere.com\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean name=\u0026#34;p-namespace\u0026#34; class=\u0026#34;com.example.ExampleBean\u0026#34; p:email=\u0026#34;someone@somewhere.com\u0026#34;/\u0026gt; \u0026lt;/beans\u0026gt; 该示例显示了bean定义中一个名为email的p命名空间中的属性。这告诉Spring包含一个属性声明。如前所述，p-命名空间没有模式定义，因此可以将属性名设置为配置名。\n下一个示例包括另外两个bean定义，它们都引用了另一个bean：\n源码如下：\n\u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:p=\u0026#34;http://www.springframework.org/schema/p\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;bean name=\u0026#34;john-classic\u0026#34; class=\u0026#34;com.example.Person\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;John Doe\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;spouse\u0026#34; ref=\u0026#34;jane\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean name=\u0026#34;john-modern\u0026#34; class=\u0026#34;com.example.Person\u0026#34; p:name=\u0026#34;John Doe\u0026#34; p:spouse-ref=\u0026#34;jane\u0026#34;/\u0026gt; \u0026lt;bean name=\u0026#34;jane\u0026#34; class=\u0026#34;com.example.Person\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;Jane Doe\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 此示例不仅包括使用p命名空间的属性值，还使用特殊格式声明属性引用。第一个bean定义使用\u0026lt;property name=\u0026quot;spouse\u0026quot; ref=\u0026quot;jane\u0026quot;/\u0026gt;来创建从bean john对bean jane的引用，而第二个bean定义使用p:spouse-ref=\u0026quot;jane\u0026quot;作为属性来执行完全相同的操作。在本例中，spouse是属性名，而-ref部分表示这不是一个直接的值，而是对另一个bean的引用。\np命名空间不如标准XML格式灵活。例如，用于声明属性引用的格式与以Ref结尾的属性冲突，而标准XML格式则不冲突。我们建议您慎重选择您的方法，并将此告知您的团队成员，以避免生成同时使用这三种方法的XML文档。  使用c-命名空间的XML快捷方式 #  与p-命名空间的XML快捷方式类似，Spring3.1中引入的c-命名空间允许使用行内属性来配置构造函数参数，而不是嵌套的constructor-arg元素。\n以下示例使用c:命名空间执行与基于构造函数的依赖注入相同的操作：\n\u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:c=\u0026#34;http://www.springframework.org/schema/c\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;beanTwo\u0026#34; class=\u0026#34;x.y.ThingTwo\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;beanThree\u0026#34; class=\u0026#34;x.y.ThingThree\u0026#34;/\u0026gt; \u0026lt;!-- 使用可选参数名称的传统声明方式 --\u0026gt; \u0026lt;bean id=\u0026#34;beanOne\u0026#34; class=\u0026#34;x.y.ThingOne\u0026#34;\u0026gt; \u0026lt;constructor-arg name=\u0026#34;thingTwo\u0026#34; ref=\u0026#34;beanTwo\u0026#34;/\u0026gt; \u0026lt;constructor-arg name=\u0026#34;thingThree\u0026#34; ref=\u0026#34;beanThree\u0026#34;/\u0026gt; \u0026lt;constructor-arg name=\u0026#34;email\u0026#34; value=\u0026#34;something@somewhere.com\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!-- 使用参数名的c-命名空间声明 --\u0026gt; \u0026lt;bean id=\u0026#34;beanOne\u0026#34; class=\u0026#34;x.y.ThingOne\u0026#34; c:thingTwo-ref=\u0026#34;beanTwo\u0026#34; c:thingThree-ref=\u0026#34;beanThree\u0026#34; c:email=\u0026#34;something@somewhere.com\u0026#34;/\u0026gt; \u0026lt;/beans\u0026gt; c:命名空间使用与p:（对于bean引用尾部会有-ref）相同的约定，通过名称设置构造函数参数。类似地，它需要在XML文件中声明，即使它没有在XSD schema中定义（它存在于Spring内核中）。\n对于构造函数参数名称不可用的罕见情况（通常是在字节码编译时没有调试信息），作为退路可以使用参数索引，如下所示：\n\u0026lt;!-- c-命名空间 索引定义 --\u0026gt; \u0026lt;bean id=\u0026#34;beanOne\u0026#34; class=\u0026#34;x.y.ThingOne\u0026#34; c:_0-ref=\u0026#34;beanTwo\u0026#34; c:_1-ref=\u0026#34;beanThree\u0026#34; c:_2=\u0026#34;something@somewhere.com\u0026#34;/\u0026gt; 由于XML语法的原因，索引表示法要求必须以_开头，因为XML属性名称不能以数字开头（即使某些IDE允许）。对于\u0026lt;constructor-arg\u0026gt;元素，也可以使用相应的索引表示法，但并不常用，因为声明的简单顺序通常就足够了。  实际上，构造函数解析机制在匹配参数方面非常有效，因此除非您真的需要，否则我们建议在整个配置中使用名称表示法。\n复合属性名 #  设置bean属性时，可以使用复合属性名或嵌套属性名，只要路径上的所有组件（最终属性名除外）都不为null。考虑下面的bean定义：\n\u0026lt;bean id=\u0026#34;something\u0026#34; class=\u0026#34;things.ThingOne\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;fred.bob.sammy\u0026#34; value=\u0026#34;123\u0026#34; /\u0026gt; \u0026lt;/bean\u0026gt; something bean有一个fred属性，fred有一个bob属性，bob有一个sammy属性，最后的sammy属性被设置为值123。为了使其能达到目的，something的fred属性和fred的bob属性在构建bean后不能为null。否则，将抛出NullPointerException。\n1.4.3 使用depends-on #  如果一个bean是另一个bean的依赖项，这通常意味着一个bean被设置为另一个bean的属性。通常，在基于XML的配置元数据中您可以通过\u0026lt;ref/\u0026gt;元素来实现这一点。然而，有时候bean之间的依赖关系不那么直接。例如，需要触发类中的静态初始化器，例如数据库驱动程序注册。depends-on属性可以显式地强制一个或多个bean在使用该元素的bean初始化之前进行初始化。以下示例使用depends-on属性表示对单个bean的依赖关系：\n\u0026lt;bean id=\u0026#34;beanOne\u0026#34; class=\u0026#34;ExampleBean\u0026#34; depends-on=\u0026#34;manager\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;manager\u0026#34; class=\u0026#34;ManagerBean\u0026#34; /\u0026gt; 要表示对多个bean的依赖关系，需要提供一个bean名称列表作为depends-on属性的值（逗号、空格和分号都是有效的分隔符）：\n\u0026lt;bean id=\u0026#34;beanOne\u0026#34; class=\u0026#34;ExampleBean\u0026#34; depends-on=\u0026#34;manager,accountDao\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;manager\u0026#34; ref=\u0026#34;manager\u0026#34; /\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;manager\u0026#34; class=\u0026#34;ManagerBean\u0026#34; /\u0026gt; \u0026lt;bean id=\u0026#34;accountDao\u0026#34; class=\u0026#34;x.y.jdbc.JdbcAccountDao\u0026#34; /\u0026gt; depends-on属性既可以指定初始化时间依赖，也可以指定相应的销毁时间依赖（仅在单例bean的情况下）。通过depends-on定义与给定bean关系的依赖bean首先被销毁，然后再销毁给定bean本身。因此，depends-on还可以控制程序退出的顺序。  1.4.4 延迟初始化bean #  默认情况下，ApplicationContext实现在初始化过程中早早地创建和配置好所有的单例bean。通常，这种预实例化是可取的，因为配置或周围环境中的错误会立即被发现，而不是数小时甚至数天之后。当这种行为不可取时，可以通过将bean定义标记为延迟初始化来防止单例bean的预实例化。延迟初始化bean告诉IoC容器在第一次请求时而不是在启动时创建bean实例。\n在XML中，此行为由\u0026lt;bean/\u0026gt;元素上的lazy-init属性控制，如下例所示：\n\u0026lt;bean id=\u0026#34;lazy\u0026#34; class=\u0026#34;com.something.ExpensiveToCreateBean\u0026#34; lazy-init=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;bean name=\u0026#34;not.lazy\u0026#34; class=\u0026#34;com.something.AnotherBean\u0026#34;/\u0026gt; 当前面的配置被ApplicationContext使用时，当ApplicationContext启动，lazy bean并不急于预实例化，而not.lazy bean则会立即预实例化。\n但是，当延迟初始化bean是非延迟初始化的单例bean的依赖项时，ApplicationContext会在启动时创建延迟初始化的bean，因为它必须满足单例的依赖项。延迟初始化bean被注入到其他地方的非延迟初始化的单例bean中。\n您还可以通过在\u0026lt;beans/\u0026gt;元素上使用default-lazy-init属性来控制容器级别的延迟初始化，如下示例所示：\n\u0026lt;beans default-lazy-init=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;!-- 没有bean会被预实例化... --\u0026gt; \u0026lt;/beans\u0026gt; 1.4.5 自动装配协作者 #  Spring容器可以自动装配协作bean之间的关系。通过检查ApplicationContext的内容，您可以让Spring为您的bean自动解析协作者（其他bean）。自动装配具有以下优点：\n 自动装配可以显著减少需要指定的属性或构造函数参数（在这方面，本章其他地方讨论的其他机制（如bean模板）也很有价值。） 自动装配可以随着对象的演变而更新配置。例如，如果您需要向类添加依赖项，该依赖项则可以自动满足，而无需修改配置。因此，在开发过程中，自动装配特别有用，而不会在代码库变得更稳定时取消切换到显式装配的选项。  使用基于XML的配置元数据时（请参见依赖注入），可以使用\u0026lt;bean/\u0026gt;元素的autowire属性为bean定义指定自动装配模式。自动装配功能有四种模式，您可以为每个bean指定自动装配，从而可以选择要自动装配的bean。下表介绍了四种自动装配模式：\n表2. 自动装配模式\n   模式 解释     no （默认）无自动装配。bean引用必须由ref元素定义。对于较大的部署，不建议更改默认设置，因为明确指定协作者可以提供更好的控制和清晰度。在某种程度上，它记录了一个系统的结构。   byName 按属性名称自动装配。Spring查找与需要自动装配的属性同名的bean。例如，如果一个bean定义被设置为按名称自动装配，并且它包含一个master属性（即，它有一个setMaster(..)方法），Spring将查找一个名为master的bean定义并使用它来设置属性。   byType 如果容器中正好存在一个属性类型的bean，则可以自动装配该属性。如果存在多个，将抛出一个致命异常，这表示您可能不应该对该bean使用byType自动装配。如果没有匹配的bean，则不会发生任何事情（未设置属性）。   constructor 类似于byType，但适用于构造函数参数。如果容器中没有该构造函数参数类型的bean，则会引发致命错误。    使用byType或constructor自动装配模式，可以装配数组和类型化集合。在这种情况下，将提供容器中与预期类型匹配的所有自动装配候选项以满足依赖关系。如果所需的键类型为String，则可以自动装配强类型Map实例。自动装配Map实例的值由与预期类型匹配的所有bean实例组成，Map实例的键包含相应的bean名称。\n自动装配的局限性和缺点 #  在整个项目中一致使用自动装配时效果最佳。如果通常不使用自动装配，那么仅使用它装配一个或两个bean定义可能会让开发人员感到困惑。\n考虑如下自动装配的局限性和缺点：\n property和constructor-arg设置中的显式依赖项始终会覆盖自动装配。不能自动装配简单属性，例如基本数据类型、Strings和Classes（以及此类简单属性的数组）。这一限制是由设计造成的。 自动装配不如显式装配精确。尽管如此，如前表所述，Spring小心避免在可能产生意外结果的歧义情况下进行猜测。Spring托管对象之间的关系不再明确记录。 装配信息也需不适用于可能从Spring容器生成文档的工具。 容器中的多个bean定义可能与要自动装配的setter方法或构造函数参数指定的类型匹配。对于数组、集合或Map实例，这不一定是问题。然而，对于期望单个值的依赖项，这种模糊性并不是随意解决的。如果没有唯一的bean定义可用，将引发异常。  在后一种情况下，您有几个选项：\n 放弃自动装配，采用显式装配。 通过将bean定义的autowire-candidate属性设置为false，以避免自动装配，如下一节所述。 通过将其\u0026lt;bean/\u0026gt;元素的primary属性设置为true，将单个bean定义指定为主要候选项。 如基于注解的容器配置中所述，使用基于注解的配置实现更细粒度的控制。  从自动装配中排除bean #  在每个bean的基础上，您可以将bean从自动装配中排除。在Spring的XML格式中，将\u0026lt;bean/\u0026gt;元素的autowire-candidate属性设置为false。该容器使该特定bean定义对自动装配基础结构（包括注解放个配置，如@Autowired）不可用。\nautowire-candidate属性被设计为仅影响基于类型的自动装配。它不会通过名称影响显式引用，即使指定的bean未标记为自动装配候选，也会解析显式的引用。因此，如果名称匹配，按名称自动装配将注入该bean。  您还可以基于对bean名称的模式匹配来限制自动装配候选项。顶级\u0026lt;beans/\u0026gt;元素在其default-autowire-candidates属性中接受一个或多个模式。例如，要将自动装配候选状态限制为名称以Repository结尾的任何bean，那请提供值*Repository。要提供多个模式，请在逗号分隔的列表中定义它们。bean定义的autowire-candidate属性的显式值true或false始终更优先。对于这样的bean，模式匹配规则不适用。\n这些技术对于您永远不希望通过自动装配注入其他bean的bean非常有用。这并不意味着排除的bean本身不能通过使用自动装配进行配置。相反，bean本身不是自动装配其他bean的候选对象。\n1.4.6 方法注入 #  在大多数应用程序场景中，容器中的大多数bean都是单例的。当一个单例bean需要与另一个单例bean协作，或者一个非单例bean需要与另一个非单例bean协作时，通常通过将一个bean定义为另一个bean的属性来处理依赖关系。当bean的生命周期不同时，就会出现问题。假设单例bean A可能是在A上的每个方法调用时需要使用非单例（原型）bean B，。容器只创建单例bean A一次，因此只有一次机会设置属性。容器不能在每次需要时为bean A提供bean B的新实例。\n一个解决办法是放弃部分控制反转。您可以通过实现ApplicationContextAware接口使bean A对容器有所感知，并在每次bean A需要时对容器发出getBean(\u0026quot;B\u0026quot;)调用以请求（通常是新的）bean B实例。以下示例展示了此方法：\nJava // 使用有状态的命令风格类执行某些处理的类 package fiona.apple; // 导入Spring的相关API import org.springframework.beans.BeansException; import org.springframework.context.ApplicationContext; import org.springframework.context.ApplicationContextAware; public class CommandManager implements ApplicationContextAware { private ApplicationContext applicationContext; public Object process(Map commandState) { // 获取相应Command的新实例  Command command = createCommand(); // 在（希望是全新的）Command实例上设置状态  command.setState(commandState); return command.execute(); } protected Command createCommand() { // 注意Spring API的依赖关系！  return this.applicationContext.getBean(\u0026#34;command\u0026#34;, Command.class); } public void setApplicationContext( ApplicationContext applicationContext) throws BeansException { this.applicationContext = applicationContext; } } Kotlin // 使用有状态的命令风格类执行某些处理的类 package fiona.apple // 导入Spring的相关API import org.springframework.context.ApplicationContext import org.springframework.context.ApplicationContextAware class CommandManager : ApplicationContextAware { private lateinit var applicationContext: ApplicationContext fun process(commandState: Map\u0026lt;*, *\u0026gt;): Any { // 获取相应Command的新实例  val command = createCommand() // 在（希望是全新的）Command实例上设置状态  command.state = commandState return command.execute() } // 注意Spring API的依赖关系！  protected fun createCommand() = applicationContext.getBean(\u0026#34;command\u0026#34;, Command::class.java) override fun setApplicationContext(applicationContext: ApplicationContext) { this.applicationContext = applicationContext } }  前面的内容是不可取的，因为业务代码能感知到Spring框架并与之耦合。方法注入是Spring IoC容器的一个稍微高级的特性，它允许您干净地处理这种场景。\n您可以在这篇博客文章中阅读更多关于方法注入动机的信息。  查找方法注入 #  查找方法注入是容器重写容器管理bean上的方法并返回容器中另一个命名bean的查找结果的能力。查找通常涉及一个原型bean，如前一节所述。Spring框架通过使用CGLIB库中的字节码生成来动态生成重写该方法的子类，从而实现这种方法注入。\n 为了使这个动态子类能够工作，Spring bean容器子类的类不能是final，要重写的方法也不能是final。 对具有abstract方法的类进行单元测试需要您自己对该类进行子类化，并提供abstract方法的存根实现。 组件扫描还需要具体的方法，这需要具体的类来提供。 另一个关键限制是，查找方法不适用于工厂方法，特别是配置类中的@Bean方法，因为在这种情况下，容器不负责创建实例，因此无法动态创建运行时生成的子类。   对于前面代码段中的CommandManager类，Spring容器动态重写createCommand()方法的实现。CommandManager类没有任何Spring依赖项，修改后的示例如下所示：\nJava package fiona.apple; // 没有Spring导入  public abstract class CommandManager { public Object process(Object commandState) { // 获取相应Command接口的新实例  Command command = createCommand(); // 在（希望是全新的）Command实例上设置状态  command.setState(commandState); return command.execute(); } // 可以，但是这种方法的实现在哪里呢？  protected abstract Command createCommand(); } Kotlin package fiona.apple // 没有Spring导入  abstract class CommandManager { fun process(commandState: Any): Any { // 获取相应Command接口的新实例  val command = createCommand() // 在（希望是全新的）Command实例上设置状态  command.state = commandState return command.execute() } // 可以，但是这种方法的实现在哪里呢？  protected abstract fun createCommand(): Command }  在包含要注入的方法的客户端类（本例中为CommandManager）中，要注入的方法需要以下形式的签名：\n\u0026lt;public|protected\u0026gt; [abstract] \u0026lt;return-type\u0026gt; theMethodName(no-arguments); 如果方法是abstract的，则动态生成的子类将实现该方法。否则，动态生成的子类将重写在原始类中定义的具体方法。考虑下面的例子：\n\u0026lt;!-- 作为原型部署的有状态bean（非单例） --\u0026gt; \u0026lt;bean id=\u0026#34;myCommand\u0026#34; class=\u0026#34;fiona.apple.AsyncCommand\u0026#34; scope=\u0026#34;prototype\u0026#34;\u0026gt; \u0026lt;!-- 根据需要在此处注入依赖项 --\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!-- commandProcessor使用statefulCommandHelper --\u0026gt; \u0026lt;bean id=\u0026#34;commandManager\u0026#34; class=\u0026#34;fiona.apple.CommandManager\u0026#34;\u0026gt; \u0026lt;lookup-method name=\u0026#34;createCommand\u0026#34; bean=\u0026#34;myCommand\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; 当需要myCommand bean的新实例时，标识为commandManager的bean就会调用自己的createCommand()方法。如果需要的话，您必须注意将myCommand bean部署为原型。如果是单例，则每次都返回相同的myCommand bean实例。\n或者，在基于注解的组件模型中，可以通过@Lookup注解声明查找方法，如下例所示：\nJava public abstract class CommandManager { public Object process(Object commandState) { Command command = createCommand(); command.setState(commandState); return command.execute(); } @Lookup(\u0026#34;myCommand\u0026#34;) protected abstract Command createCommand(); } Kotlin abstract class CommandManager { fun process(commandState: Any): Any { val command = createCommand() command.state = commandState return command.execute() } @Lookup(\u0026#34;myCommand\u0026#34;) protected abstract fun createCommand(): Command }  或者，更习惯地，您可以依靠目标bean根据查找方法的声明返回类型进行解析：\nJava public abstract class CommandManager { public Object process(Object commandState) { MyCommand command = createCommand(); command.setState(commandState); return command.execute(); } @Lookup protected abstract MyCommand createCommand(); } Kotlin abstract class CommandManager { fun process(commandState: Any): Any { val command = createCommand() command.state = commandState return command.execute() } @Lookup protected abstract fun createCommand(): Command }  请注意，您通常应该使用具体的存根实现声明此类带注解的查找方法，以便它们与Spring的组件扫描规则兼容，默认情况下抽象类会被忽略。此限制不适用于显式注册或显式导入的bean类。\n另一种访问不同范围的目标bean的方法是ObjectFactory/Provider注入点。参考有作用域的bean作为依赖项。\n您还可能发现ServiceLocatoryFactoryBean（在org.springframework.beans.factory.config包中）很有用。\n 任意方法替换 #  与查找方法注入相比，方法注入的一种不太有用的形式是能够用另一种方法实现替换托管bean中的任意方法。在实际需要此功能之前，您可以安全地跳过本节的其余部分。\n对于基于XML的配置元数据，对于已部署的bean，可以使用replaced-method元素将现有的方法实现替换为另一个方法实现。考虑下面的类，它有一个我们想重写的叫做computeValue的方法：\nJava public class MyValueCalculator { public String computeValue(String input) { // 一些真实的代码...  } // 一些其他方法... } Kotlin class MyValueCalculator { fun computeValue(input: String): String { // 一些真实的代码...  } // 一些其他方法... }  一个实现了org.springframework.beans.factory.support.MethodReplacer接口的类提供了新的方法定义，如下例所示：\nJava /** * 用于MyValueCalculator中重写现有的computeValue(String)实现 */ public class ReplacementComputeValue implements MethodReplacer { public Object reimplement(Object o, Method m, Object[] args) throws Throwable { // 获取输入值，使用它，并返回计算结果  String input = (String) args[0]; ... return ...; } } Kotlin /** * 用于MyValueCalculator中重写现有的computeValue(String)实现 */ class ReplacementComputeValue : MethodReplacer { override fun reimplement(obj: Any, method: Method, args: Array\u0026lt;out Any\u0026gt;): Any { // 获取输入值，使用它，并返回计算结果  val input = args[0] as String; ... return ...; } }  部署原始类并指定方法重写的bean定义类似于以下示例：\n\u0026lt;bean id=\u0026#34;myValueCalculator\u0026#34; class=\u0026#34;x.y.z.MyValueCalculator\u0026#34;\u0026gt; \u0026lt;!-- 任意方法替换 --\u0026gt; \u0026lt;replaced-method name=\u0026#34;computeValue\u0026#34; replacer=\u0026#34;replacementComputeValue\u0026#34;\u0026gt; \u0026lt;arg-type\u0026gt;String\u0026lt;/arg-type\u0026gt; \u0026lt;/replaced-method\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;replacementComputeValue\u0026#34; class=\u0026#34;a.b.c.ReplacementComputeValue\u0026#34;/\u0026gt; 您可以在\u0026lt;replaced-method/\u0026gt;元素中使用一个或多个\u0026lt;arg-type/\u0026gt;元素来指定要重写的方法的方法签名。只有当方法重载且类中存在多种变体时，才需要参数的签名。为方便起见，参数的字符串类型可以是完全限定类名的子字符串。例如，以下所有选项都与java.lang.String匹配：\njava.lang.String String Str 由于参数的数量通常足以区分每个可能的选择，因此此快捷方式可以通过只允许键入与参数类型匹配的最短字符串来节省大量键入。\n"},{"id":8,"href":"/spring-doc/integration/jmx/","title":"4.JMX","section":"集成","content":"4. JMX #  Version 5.2.2.RELEASE\n "},{"id":9,"href":"/spring-doc/data-access/","title":"数据访问","section":"Spring框架文档","content":"数据访问 #  Version 5.2.2.RELEASE\n "},{"id":10,"href":"/spring-doc/web/mvc/","title":"1. Spring Web MVC","section":"Web Servlet","content":"1. Spring Web MVC #  Version 5.2.2.RELEASE\n "},{"id":11,"href":"/spring-doc/core/beans/beans-factory-scopes/","title":"1.5 bean的作用域","section":"1. IoC容器","content":"1.5 bean的作用域 #  Version 5.2.2.RELEASE\n 当您创建一个bean定义时，您就意味着创建了一套定义方式用于创建由该bean定义所定义的类的实际实例。bean定义是一套定义方式的思想很重要，因为这意味着，与类一样，可以基于一套定义方式创建多个对象实例。\n您不仅可以控制要插入到从特定bean定义创建的对象中的各种依赖项和配置值，还可以控制从特定bean定义创建的对象的作用域。这种方法功能强大且灵活，因为您可以选择通过配置创建的对象的作用域，而不必在Java类级别烤入对象的作用域。可以将bean定义为部署在多个作用域中的一个。Spring框架支持六个作用域，其中四个只有在使用web相关的ApplicationContext时才可用。您还可以创建自定义作用域。\n下表描述了支持的作用域：\n表3. Bean作用域\n   作用域 描述     singleton （默认）为每个Spring IoC容器将单个bean定义的作用域限定为单个对象实例。   prototype 将单个bean定义的作用域限定为任意数量的对象实例。   request 将单个bean定义的作用域限定为单次HTTP请求的生命周期。也就是说，每个HTTP请求都有自己的bean实例，该实例是在单个bean定义的后面创建的。仅在支持web的Spring ApplicationContext中有效。   session 将单个bean定义的作用域限定为HTTP Session的生命周期。仅在支持web的Spring ApplicationContext中有效。   application 将单个bean定义的作用域限定到ServletContext的生命周期。仅在支持web的Spring ApplicationContext中有效。   websocket 将单个bean定义的作用域限定到WebSocket的生命周期。仅在支持web的Spring ApplicationContext中有效。    从Spring 3.0开始，线程作用域可以使用，但默认情况下是不注册的。有关更多信息，请参阅SimpleThreadScope的文档。有关如何注册此作用域或任何其他自定义作用域的说明，请参阅使用自定义作用域。  1.5.1 单例作用域 #  一个单例bean被管理的只有一个共享实例，通过ID请求该bean定义所匹配bean的所有请求都会导致Spring容器返回该特定的bean实例。\n换句话说，当您定义一个bean定义并将其作用域限定为一个单例时，Spring IoC容器只创建该bean定义所定义对象的一个实例。这个实例存储在这些单例bean的缓存中，后续所有对该命名bean的请求和引用都返回缓存对象。下图显示了单例作用域的工作原理：\nSpring的单例bean概念不同于四人组（GoF）设计模式书中定义的单例模式。GoF单例硬编码对象的作用域，这样每个类加载器只创建一个特定类的实例。Spring单例的范围最好描述为每个容器和每个bean。这意味着，如果在单个Spring容器中为特定类定义一个bean，Spring容器将仅创建该bean定义的类的一个实例。单例作用域是Spring中的默认作用域。要在XML中将bean定义为单例，可以如下例所示定义bean：\n\u0026lt;bean id=\u0026#34;accountService\u0026#34; class=\u0026#34;com.something.DefaultAccountService\u0026#34;/\u0026gt; \u0026lt;!-- 以下是等效的，尽管多余（默认是单例作用域） --\u0026gt; \u0026lt;bean id=\u0026#34;accountService\u0026#34; class=\u0026#34;com.something.DefaultAccountService\u0026#34; scope=\u0026#34;singleton\u0026#34;/\u0026gt; 1.5.2 原型作用域 #  bean部署为非单例原型作用域将导致每次对特定bean发出请求时都创建一个新的bean实例。也就是说，bean被注入到另一个bean中，或者通过容器上的getBean()方法调用来请求它。通常，所有有状态bean都应该使用原型作用域，无状态bean应该使用单例作用域。\n下图说明了Spring的原型作用域：\n（数据访问对象（DAO）通常不配置为原型，因为典型的DAO不包含任何对话状态。我们更容易复用单例图的核心。）\n以下示例在XML中将bean定义为原型：\n\u0026lt;bean id=\u0026#34;accountService\u0026#34; class=\u0026#34;com.something.DefaultAccountService\u0026#34; scope=\u0026#34;prototype\u0026#34;/\u0026gt; 与其他作用域不同，Spring并不管理原型bean的整个生命周期。容器实例化、配置和以其他方式组装原型对象并将其交给客户端，而不再记录该原型实例。因此，尽管对所有对象调用初始化生命周期回调方法，而不考虑作用域，但对于原型，不会调用配置的销毁生命周期回调。客户端代码必须清理原型作用域的对象，并释放原型bean所持有的昂贵资源。要让Spring容器释放原型作用域的bean所持有的资源，请尝试使用定制的bean后置处理器，该后置处理器持有对需要清理的bean的引用。\n在某些方面，Spring容器在原型作用域bean中的角色是Java new操作符的替代品。所有超过该点的生命周期管理都必须由客户端处理。（有关Spring容器中bean生命周期的详细信息，请参阅生命周期回调。）\n1.5.3 具有原型bean依赖项的单例bean #  当您使用依赖项为原型bean的单例bean时，请注意，依赖项是在实例化时处理的。因此，如果将原型bean作为依赖项注入到单例bean中时，那么将实例化一个新的原型bean，然后将它作为依赖项注入到单例bean中。该原型实例是唯一一个提供给单例bean的实例。\n但是，假设您希望单例bean在运行时可重复获取原型bean的新实例。那么您不能将原型bean依赖注入到您的单例bean中，因为当Spring容器实例化单例bean并解析和注入其依赖项时，注入只发生一次。如果在运行时多次需要原型bean的新实例，请参阅方法注入。\n1.5.4 Request、Session、Application和WebSocket作用域 #  request、session、application和websocket作用域仅在用于web相关的Spring ApplicationContext实现（如XmlWebApplicationContext）中可用。如果将这些作用域用于常规Spring IoC容器（如ClassPathXmlApplicationContext），则会引发一个关于未知bean作用域的IllegalStateException。\n初始Web配置 #  为了在request、session、application和websocket级别（web范围的bean）支持bean的作用域，在定义bean之前需要进行一些较小的初始配置。（标准作用域singleton和prototype不需要此初始设置。）\n如何完成初始设置取决于特定的Servlet环境。\n如果您在Spring WebMVC中访问作用域bean，请求实际上是在Spring DispatcherServlet处理的，则不需要特殊设置。DispatcherServlet已公开所有相关状态。\n如果使用Servlet 2.5 web容器，请求是在Spring的DispatcherServlet之外处理（例如，当使用JSF或Struts时），则需要注册org.springframework.web.context.request.RequestContextListener ServletRequestListener。对于Servlet 3.0+，这可以通过使用WebApplicationInitializer接口以编程方式完成。或者，对于旧容器，将以下声明添加到web应用程序的web.xml文件中：\n\u0026lt;web-app\u0026gt; ... \u0026lt;listener\u0026gt; \u0026lt;listener-class\u0026gt; org.springframework.web.context.request.RequestContextListener \u0026lt;/listener-class\u0026gt; \u0026lt;/listener\u0026gt; ... \u0026lt;/web-app\u0026gt; 或者，如果您的监听器设置存在问题，请考虑使用Spring的RequestContextFilter过滤器。过滤器映射取决于周围的web应用程序配置，因此必须根据需要进行更改。以下列表展示了web应用程序的过滤器部分：\n\u0026lt;web-app\u0026gt; ... \u0026lt;filter\u0026gt; \u0026lt;filter-name\u0026gt;requestContextFilter\u0026lt;/filter-name\u0026gt; \u0026lt;filter-class\u0026gt;org.springframework.web.filter.RequestContextFilter\u0026lt;/filter-class\u0026gt; \u0026lt;/filter\u0026gt; \u0026lt;filter-mapping\u0026gt; \u0026lt;filter-name\u0026gt;requestContextFilter\u0026lt;/filter-name\u0026gt; \u0026lt;url-pattern\u0026gt;/*\u0026lt;/url-pattern\u0026gt; \u0026lt;/filter-mapping\u0026gt; ... \u0026lt;/web-app\u0026gt; DispatcherServlet、RequestContextListener和RequestContextFilter都执行完全相同的操作，即将HTTP请求对象绑定到为该请求提供服务的Thread。这使得请求和会话作用域的bean在调用链的更下游可用。\n请求作用域 #  Session作用域 #  应用作用域 #  有作用域的bean作为依赖项 #  1.5.5 自定义作用域 #  使用自定义作用域 #  "},{"id":12,"href":"/spring-doc/web/webmvc-client/","title":"2. REST客户端","section":"Web Servlet","content":"2. REST客户端 #  Version 5.2.2.RELEASE\n "},{"id":13,"href":"/spring-doc/web/testing/","title":"3. 测试","section":"Web Servlet","content":"3. 测试 #  Version 5.2.2.RELEASE\n "},{"id":14,"href":"/spring-doc/web/websocket/","title":"4. WebSocket","section":"Web Servlet","content":"4. WebSocket #  Version 5.2.2.RELEASE\n "},{"id":15,"href":"/spring-doc/web/websocket/websocket-stomp/","title":"4.4 STOMP","section":"4. WebSocket","content":"4.4 STOMP #  Version 5.2.2.RELEASE\n 4.4.19 WebSocket作用域 #  "},{"id":16,"href":"/spring-doc/web/web-integration/","title":"5. 其他Web框架","section":"Web Servlet","content":"5. 其他Web框架 #  Version 5.2.2.RELEASE\n "},{"id":17,"href":"/spring-doc/web/","title":"Web Servlet","section":"Spring框架文档","content":"Web Servlet #  Version 5.2.2.RELEASE\n "},{"id":18,"href":"/spring-doc/core/beans/beans-factory-nature/","title":"1.6 自定义Bean的性质","section":"1. IoC容器","content":"1.6 自定义Bean的性质 #  Version 5.2.2.RELEASE\n 1.6.1 生命周期回调 #  初始化时回调 #  销毁时回调 #  1.6.2. ApplicationContextAware 和 BeanNameAware #  "},{"id":19,"href":"/spring-doc/web-reactive/","title":"响应式Web","section":"Spring框架文档","content":"响应式Web #  Version 5.2.2.RELEASE\n "},{"id":20,"href":"/spring-doc/core/beans/beans-child-bean-definitions/","title":"1.7 bean定义继承","section":"1. IoC容器","content":"1.7 bean定义继承 #  Version 5.2.2.RELEASE\n "},{"id":21,"href":"/spring-doc/integration/","title":"集成","section":"Spring框架文档","content":"集成 #  Version 5.2.2.RELEASE\n "},{"id":22,"href":"/spring-doc/core/beans/beans-factory-extension/","title":"1.8 容器扩展点","section":"1. IoC容器","content":"1.8 容器扩展点 #  Version 5.2.2.RELEASE\n 1.8.1 使用BeanPostProcessor自定义bean #  1.8.3 使用FactoryBean自定义实例化逻辑 #  "},{"id":23,"href":"/spring-doc/languages/","title":"支持的语言","section":"Spring框架文档","content":"支持的语言 #  Version 5.2.2.RELEASE\n "},{"id":24,"href":"/spring-doc/core/beans/beans-annotation-config/","title":"1.9 基于注解的容器配置","section":"1. IoC容器","content":"1.9 基于注解的容器配置 #  Version 5.2.2.RELEASE\n 1.9.1 @Required #  1.9.2 使用@Autowired #  1.9.3 使用@Primary微调基于注解的自动装配 #  1.9.4 使用限定符微调基于注解的自动装配 #  dependencies { annotationProcessor \u0026#34;org.springframework:spring-context-indexer:{spring-version}\u0026#34; } == 基于Java的容器配置 本节介绍如何在Java代码中使用注解来配置Spring容器。它包括以下主题：\n [基本概念：@Bean和@Configuration] [使用AnnotationConfigApplicationContext实例化Spring容器] [@Bean注解使用] [@Configuration注解使用] [组合基于Java的配置] [bean定义配置] [PropertySource抽象] [使用PropertySource] [语句中的占位符解析]  === 基本概念：@Bean和@Configuration === 使用AnnotationConfigApplicationContext实例化Spring容器 === @Bean注解使用 === @Configuration注解使用  === 组合基于Java的配置  ==== XML Bean定义概要文件\n=== bean定义配置 === PropertySource抽象  最重要的是，\n=== 使用@PropertySource === 语句中的占位符解析 === Web应用简单的ApplicationContext实例化 == BeanFactory BeanFactory API为Spring的IoC功能提供了基础。它特定的约定主要用于与Spring的其他部分和相关第三方框架集成，其DefaultListableBeanFactory实现是更高级别的GenericaApplicationContext容器中的一个关键代表。\nBeanFactory和相关接口（如BeanFactoryAware、InitializingBean、DisposableBean）是其他框架组件的重要集成点。通过不需要任何注解甚至反射，它们允许容器及其组件之间进行非常有效的交互。应用级的bean可以使用相同的回调接口，但通常更喜欢声明式地依赖项注入，要么通过注解，要么通过编程配置。\n请注意，核心BeanFactory API级别及其DefaultListableBeanFactory实现不对要使用的配置格式或任何组件注释进行假设。所有这些风格都是通过扩展（如XmlBeanDefinitionReader和AutowiredNotationBeanPostProcessor）引入的，并作为核心元数据表示在共享BeanDefinition对象上操作。这就是Spring容器如此灵活和可扩展的本质所在。\n=== BeanFactory还是ApplicationContext？\n本节讲解BeanFactory和ApplicationContext容器级别之间的差异以及对引导的影响。\n除非有充分的理由，否则你应该使用ApplicationContext，将GenericaApplicationContext及其子类AnnotationConfigApplicationContext作为自定义引导的常见实现。这些是Spring核心容器的主要切入点，用于所有常见目的：加载配置文件、触发类路径扫描、以编程方式注册bean定义和注解类，以及（从5.0开始）注册函数bean定义。\n = 资源 == 应用上下文与资源路径  === 使用AspectJ向Spring注入依赖域对象  Ant风格\n=== ConversionService接口  === 理解AOP代理\n=== 基础 == XML Schemas  "}]