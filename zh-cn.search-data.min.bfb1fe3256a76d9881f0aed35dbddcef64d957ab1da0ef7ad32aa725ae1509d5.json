[{"id":0,"href":"/spring-doc/core/ioc-container/","title":"1. IoC容器","section":"核心技术","content":"1. IoC容器 #  Version 5.2.2.RELEASE\n 本章介绍Spring的控制反转（IoC）容器。\n"},{"id":1,"href":"/spring-doc/core/ioc-container/beans-introduction/","title":"1.1 Spring IoC容器和Beans简介","section":"1. IoC容器","content":"1.1 Spring IoC容器和Beans简介 #  Version 5.2.2.RELEASE\n 本章介绍Spring框架中控制反转（IoC）理念的实现。IoC也称为依赖注入（DI）。这是一个过程，对象仅通过构造函数参数、工厂方法的参数、在对象实例构造或从工厂方法返回后在对象实例上设置的属性来定义它们的依赖关系（即它们使用的其他对象）。然后，容器在创建这个bean时注入这些依赖项。这个过程基本上是bean本身通过使用类的直接构造或服务定位器模式等机制来控制其依赖项的实例化或位置完全相反（因此称为控制反转）。\norg.springframework.bean和org.springframework.context包是Spring框架中IoC容器的基础。BeanFactory接口提供了一种高级配置机制，能够管理任何类型的对象。ApplicationContext是BeanFactory的子接口。它补充了：\n 更容易与Spring的AOP功能集成 信息资源处理（用于国际化） 事件发布 应用层特定的上下文，如web应用程序中使用的WebApplicationContext。  简而言之，BeanFactory提供了配置框架和基本功能，ApplicationContext添加了更多特定于企业级的功能。ApplicationContext是BeanFactory的完整超集，在本章中专门用于描述Spring的IoC容器。有关使用BeanFactory而不是ApplicationContext的更多信息，请参阅[BeanFactory]。\n在Spring中，构成应用程序主干并由Spring IoC容器管理的对象称为bean。bean是由Spring IoC容器实例化、装配和管理的对象。除此之外，bean只是应用程序许多对象中的一个。bean以及它们之间的依赖关系反映在容器所使用的配置元数据中。\n"},{"id":2,"href":"/spring-doc/overview/","title":"Spring框架概述","section":"Spring框架文档","content":"Spring框架概述 #  Version 5.2.2.RELEASE\n Spring让创建企业级的Java应用变得更简单。它提供了在企业环境中使用Java语言所需的一切，支持Groovy和Kotlin作为JVM上的替代语言，并具有根据应用程序的需要而创建多种体系结构的灵活性。从Spring框架5.1开始，Spring需要JDK8+（Java SE 8+）并为JDK 11 LTS提供开箱即用的支持。建议使用Java SE 8 update 60作为Java 8的最低补丁版本，但通常更建议使用最新的补丁版本。\nSpring支持广泛的应用场景。在大型企业中，应用程序通常存在了很长时间，并且必须在JDK和应用程序服务器上运行，其升级周期超出了开发人员的控制。其他的可能作为一个jar运行，服务器可能嵌入到云环境中。还有一些可能是不需要服务器的独立应用程序（如批处理或集成工作负载）。\nSpring是开源的。它有一个庞大而活跃的社区，根据各种各样的实际用例提供持续的反馈。这帮助Spring在很长一段时间内成功地进化。\n1. 我们所说的“Spring” #  “Spring”一词在不同的语境中意味着不同的事物。它可以用来指代Spring框架项目本身，而Spring正是从这里开始的。随着时间的推移，其他Spring项目已经构建在Spring框架之上。通常，当人们说“Spring”时，他们指的是整个项目家族。这份参考文档主要关注Spring的基础：Spring框架本身。\nSpring框架分为几个模块，应用程序可以选择他们需要的模块。核心容器模块是核心，包括了配置模型和依赖注入机制。除此之外，Spring框架还为不同的应用程序体系结构提供了基础支持，包括消息传递、事务数据和持久化以及web服务。它还包括基于Servlet的Spring MVC框架和Spring WebFlux反应式web框架。\n关于模块的注意事项：Spring的framework jar允许部署到Jdk9的模块路径（“Jigsaw”）。为了在开启Jigsaw的应用程序中使用，Spring框架5个jar附带了“Automatic-Module-Name”清单条目，这些条目定义了独立于jar artifact的稳定语言级模块名（“spring.core”、“spring.context”等）（jar遵循相同的命名模式，用“-”代替“.”，例如“spring-core”和“spring-context”）。当然，Spring的framework jar在JDK8和JDK9+上的类路径上都能正常工作。\n 2. Spring和Spring框架的历史 #  Spring作为对早期J2EE规范复杂性的解决方案于2003年诞生。虽然有些人认为Java EE和Spring将处于竞争状态，但实际上，Spring是java EE的补充。Spring编程模型不支持Java EE的平台规范；相反，它与从EE旗下精心挑选的单个规范相结合：\n Servlet API (JSR 340) WebSocket API (JSR 356) Concurrency Utilities (JSR 236) JSON Binding API (JSR 367) Bean Validation (JSR 303) JPA (JSR 338) JMS (JSR 914) 以及JTA/JCA设置，以便在必要时进行事务协调。  Spring框架还支持依赖注入（JSR 330）和公共注解（JSR 250）规范，应用程序开发人员可以选择使用这些规范来代替Spring框架提供的特定于Spring的机制。\n从Spring Framework 5.0开始，Spring至少需要Java EE 7的级别（例如Servlet 3.1+，JPA 2.1+），同时在运行时遇到Java EE 8级别的新API（例如Servlet 4.0，JSON Binding API）时提供开箱即用的集成。这使得Spring与Tomcat 8和9、WebSphere 9和JBoss EAP 7完全兼容。\n随着时间的推移，Java EE在应用程序开发中的角色已经发生了变化。在Java EE和Spring的早期，创建的应用程序被部署到应用服务器上。今天，在SpringBoot的帮助下，应用程序只需要微不足道的改动就可以通过嵌入式Servlet容器以devops和云友好的方式创建的。从Spring Framework 5开始，WebFlux应用程序甚至不直接使用Servlet API，可以在不是Servlet容器的服务器（比如Netty）上运行。\nSpring将继续创新和进化。除了Spring框架，还有其他项目，比如Spring Boot、Spring Security、Spring Data、Spring Cloud、Spring Batch等等。重要的是要记住，每个项目都有自己的代码库、问题跟踪器和发布节奏。有关Spring项目的完整列表，请参见spring.io/projects。\n 3. 设计理念 #  当您学习一个框架时，不仅要知道它做什么，还要知道它遵循什么原则。以下是Spring框架的指导原则：\n 在各个级别提供选择。Spring允许您尽可能推迟设计决策。例如，您可以通过配置切换持久化提供程序，而无需更改代码。许多其他基础架构问题和与第三方API的集成也是如此。 适应不同的视角。Spring具有灵活性，对于应该如何做并不固执己见。它以不同的视角支持广泛的应用需求。 保持强大的向后兼容性。Spring的发展经过了精心管理，在版本之间几乎没有突破性的变化。Spring支持一系列经过精心挑选的JDK版本和第三方库，以便于维护依赖Spring的应用程序和库。 注重API设计。Spring团队投入了大量的精力和时间来创建直观的API，这些API可以跨多个版本和多年使用。 为代码质量设置高标准。Spring框架非常强调有意义、最新和准确的javadoc。它是为数不多的几个可以声明代码结构清晰、包之间没有循环依赖关系的项目之一。   4. 反馈和贡献 #  对于“how-to”类的问题或诊断、调试问题，我们建议使用StackOverflow，并且我们有一个问题页面，其中列出了建议使用的标记。如果您非常确定Spring框架中存在问题，或者想建议一个特性，请使用GitHub Issues。\n如果您有一个解决方案或建议的修复方案，您可以在Github上提交一个pull请求。但是，请记住，对于除最琐碎的问题外的所有问题，我们希望在问题跟踪器中提交一张记录单，在那里进行讨论并留下记录以供将来参考。\n有关更多详细信息，请参见参与顶级项目页面上的指导原则。\n 5. 入门 #  如果您刚刚开始使用Spring，那么您可能希望通过创建一个基于Spring Boot的应用程序来开始使用Spring框架。Spring Boot提供了一种快速（而且固定）的方法来创建一个基于Spring的准生产应用程序。它基于Spring框架，推崇约定大于配置，旨在让您尽快启动并运行。\n您可以使用start.spring.io生成一个基本项目，或者依照某个“指南”，例如：构建RESTful Web 服务指南。除了更容易理解之外，这些指南非常聚焦于task，而且大多数都是基于Spring Boot的。它们还涵盖了在解决特定问题时可能需要考虑的Spring文件夹中的其他项目。\n"},{"id":3,"href":"/spring-doc/core/ioc-container/beans-basics/","title":"1.2 容器概述","section":"1. IoC容器","content":"1.2 容器概述 #  Version 5.2.2.RELEASE\n org.springframework.context.ApplicationContext接口就是Spring IoC容器，负责实例化、配置和装配bean。容器通过读取配置元数据获取关于实例化、配置和装配哪些对象的指令。配置元数据用XML、Java注解或Java代码表示，它可以用来表示组成应用程序的对象以及这些对象之间丰富的相互依赖关系。\nSpring提供了ApplicationContext接口的几种实现。在独立的应用中，通常创建的是ClassPathXmlApplicationContext或FileSystemXmlApplicationContext的实例。虽然XML一直是传统的定义配置元数据的格式，但您仍然可以使用Java注解或代码作为元数据格式，只需要通过提供少量XML配置来显式地开启对这些其他元数据格式的支持。\n在大多数应用程序场景中，实例化Spring IoC容器的一个或多个实例不需要显式的用户代码。例如，在web应用程序场景中，应用程序的样板web描述XML web.xml 中简单的八行（大约八行）通常就足够了（请参见[context create]）。如果您使用Spring Tool Suite（Eclipse驱动的开发环境），只需单击几下鼠标或按键，就可以轻松创建此样板配置。\n下图展示了Spring如何工作的高等级视图。您的应用程序类与配置元数据相结合，在创建和初始化ApplicationContext后，您便拥有了一个完全配置好且可执行的系统或应用程序。\n 图1. Spring IoC容器   1.2.1 配置元数据 #  如上图所示，Spring IoC容器使用一种形式的配置元数据。此配置元数据表示作为应用程序开发人员，您如何告知Spring容器实例化、配置和组装您应用程序中的对象。\n配置元数据传统上是以简单直观的XML格式提供的，本章大部分内容用它来表达Spring IoC容器的关键概念和特性的。\n基于XML的元数据不是唯一允许的配置元数据形式。Spring IoC容器本身与实际写入此配置元数据的格式完全解耦。现在，许多开发人员为他们的Spring应用选择基于Java的配置。  有关在Spring容器中使用其他形式元数据的信息，请参阅：\n 基于注解的配置：Spring 2.5引入了对基于注解的配置元数据的支持。 基于Java的配置：从Spring 3.0开始，Spring JavaConfig项目提供的许多特性成为了核心Spring框架的一部分。因此，您可以使用Java而不是XML文件来定义应用程序类外的bean。要使用这些新功能，请参阅@Configuration、@Bean、@Import和@DependsOn注解。  Spring配置至少包括一个但通常不止一个必须由容器管理的bean定义。基于XML的配置元数据将这些bean配置为顶级\u0026lt;beans/\u0026gt;元素中的\u0026lt;bean/\u0026gt;元素。Java配置通常在@Configuration类中使用@Bean注解标注的方法来定义bean。\n这些bean定义对应着构成应用程序的实际对象。通常，您定义服务层对象、数据访问对象（DAO）、表示对象（如Struts中的Action实例）、基础结构对象（如Hibernate SessionFactorys）、JMS Queues等。通常，不在容器中配置细粒度域对象，因为创建和加载域对象通常是DAO和业务逻辑的责任。但是，您可以使用Spring与AspectJ的集成来配置在IoC容器控制之外创建的对象。请参阅在Spring中使用AspectJ注入依赖域对象。\n以下示例显示了基于XML的配置元数据的基本结构：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;...\u0026#34; class=\u0026#34;...\u0026#34;\u0026gt; 1 2 \u0026lt;!-- 此处是当前bean的协作者和配置 --\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;...\u0026#34; class=\u0026#34;...\u0026#34;\u0026gt; \u0026lt;!-- 此处是当前bean的协作者和配置 --\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!-- 此处是其他的bean定义 --\u0026gt; \u0026lt;/beans\u0026gt;   1   id属性是标识单个bean定义的字符串。     2   class属性定义bean的类型并且要使用全限定的类名。    id属性的值引用协作对象。本例中的XML未展示引用协作对象。有关更多信息，请参阅依赖。\n1.2.2 初始化容器 #  传给ApplicationContext构造函数的位置路径（可以有多个）是资源字符串，容器将从各种外部资源（如本地文件系统、Java CLASSPATH等）加载配置元数据。\nJava ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;services.xml\u0026#34;, \u0026#34;daos.xml\u0026#34;); Kotlin val context = ClassPathXmlApplicationContext(\u0026#34;services.xml\u0026#34;, \u0026#34;daos.xml\u0026#34;)  在了解Spring的IoC容器之后，您可能想进一步了解Spring的Resource抽象（如[资源]中所述），它提供了一种方便的机制，通过URI语法定义的位置读取输入流。具体而言，Resource路径用于构建应用上下文，如[应用上下文与资源路径]中所述。  以下示例展示了服务层对象(services.xml)配置文件：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;!-- services --\u0026gt; \u0026lt;bean id=\u0026#34;petStore\u0026#34; class=\u0026#34;org.springframework.samples.jpetstore.services.PetStoreServiceImpl\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;accountDao\u0026#34; ref=\u0026#34;accountDao\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;itemDao\u0026#34; ref=\u0026#34;itemDao\u0026#34;/\u0026gt; \u0026lt;!-- 此处是当前bean的其他协作者和配置 --\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!-- 此处是其他服务的bean定义 --\u0026gt; \u0026lt;/beans\u0026gt; 以下示例展示了数据访问对象daos.xml文件：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;accountDao\u0026#34; class=\u0026#34;org.springframework.samples.jpetstore.dao.jpa.JpaAccountDao\u0026#34;\u0026gt; \u0026lt;!-- 此处是当前bean的其他协作者和配置 --\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;itemDao\u0026#34; class=\u0026#34;org.springframework.samples.jpetstore.dao.jpa.JpaItemDao\u0026#34;\u0026gt; \u0026lt;!-- 此处是当前bean的其他协作者和配置 --\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!-- 此处是其他数据访问对象的bean定义 --\u0026gt; \u0026lt;/beans\u0026gt; 在前面的示例中，服务层由PetStoreServiceImpl类和两个类型为JpaAccountDao和JpaItemDao（基于JPA对象关系映射标准）的数据访问对象组成。property name元素指JavaBean属性的名称，ref元素指另一个bean定义的名称。id和ref元素之间的联动表示协作对象之间的依赖关系。有关配置对象依赖的详细信息，请参见依赖。\n组合基于XML的配置元数据 #  让bean定义可以跨多个XML文件非常有用。通常，每个单独的XML配置文件都表示体系结构中的一个逻辑层或模块。\n您可以使用应用上下文构造函数从所有这些XML片段中加载bean定义。此构造函数可以获取多个Resource位置，如前一节所示。或者，使用一个或多个元素从另一个或多个文件中加载bean定义。以下示例展示了如何执行此操作：\n\u0026lt;beans\u0026gt; \u0026lt;import resource=\u0026#34;services.xml\u0026#34;/\u0026gt; \u0026lt;import resource=\u0026#34;resources/messageSource.xml\u0026#34;/\u0026gt; \u0026lt;import resource=\u0026#34;/resources/themeSource.xml\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;bean1\u0026#34; class=\u0026#34;...\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;bean2\u0026#34; class=\u0026#34;...\u0026#34;/\u0026gt; \u0026lt;/beans\u0026gt; "},{"id":4,"href":"/spring-doc/core/","title":"核心技术","section":"Spring框架文档","content":"核心技术 #  Version 5.2.2.RELEASE\n 参考文档的这一部分涵盖了Spring框架中绝对不可或缺的所有技术。\n其中最重要的是Spring框架的控制反转（IoC）容器。在对Spring框架的IoC容器进行彻底的探讨之后，Spring的面向切面编程（AOP）技术得到了全面的介绍。Spring框架有自己的AOP框架，在概念上很容易理解，它成功地解决了Java企业级编程中80%的AOP需求。\nSpring与AspectJ集成的报道（目前最丰富 — 就特征而言 — 当然，也提供了Java企业空间中最成熟的AOP实现。\n还介绍了Spring与AspectJ（就特征而言是目前最丰富的，当然也是Java企业级领域内最成熟的AOP实现）的集成。\n"},{"id":5,"href":"/spring-doc/testing/","title":"测试","section":"Spring框架文档","content":"测试 #  Version 5.2.2.RELEASE\n"},{"id":6,"href":"/spring-doc/core/ioc-container/beans-dependencies/","title":"1.4 依赖","section":"1. IoC容器","content":"1.4 依赖 #  Version 5.2.2.RELEASE\n "},{"id":7,"href":"/spring-doc/data-access/","title":"数据访问","section":"Spring框架文档","content":"数据访问 #  Version 5.2.2.RELEASE\n"},{"id":8,"href":"/spring-doc/web-servlet/","title":"Servlet栈上的Web","section":"Spring框架文档","content":"Servlet栈上的Web #  Version 5.2.2.RELEASE\n"},{"id":9,"href":"/spring-doc/web-reactive/","title":"响应式Web","section":"Spring框架文档","content":"响应式Web #  Version 5.2.2.RELEASE\n"},{"id":10,"href":"/spring-doc/integration/","title":"集成","section":"Spring框架文档","content":"集成 #  Version 5.2.2.RELEASE\n"},{"id":11,"href":"/spring-doc/languages/","title":"支持的语言","section":"Spring框架文档","content":"支持的语言 #  Version 5.2.2.RELEASE\n"},{"id":12,"href":"/spring-doc/core/ioc-container/beans-annotation-config/","title":"1.9 基于注解的容器配置","section":"1. IoC容器","content":"1.9 基于注解的容器配置 #  Version 5.2.2.RELEASE\n 1.9.1 @Required #  1.9.2 使用@Autowired #  1.9.3 使用@Primary微调基于注解的自动装配 #  1.9.4 使用限定符微调基于注解的自动装配 #  == 基于Java的容器配置  === Web应用便利的ApplicationContext实例化\n== BeanFactory\nBeanFactory API为Spring的IoC功能提供了基础。它特定的约定主要用于与Spring的其他部分和相关第三方框架集成，其DefaultListableBeanFactory实现是更高级别的GenericaApplicationContext容器中的一个关键代表。\nBeanFactory和相关接口（如BeanFactoryAware、InitializingBean、DisposableBean）是其他框架组件的重要集成点。通过不需要任何注解甚至反射，它们允许容器及其组件之间进行非常有效的交互。应用级的bean可以使用相同的回调接口，但通常更喜欢声明式地依赖项注入，要么通过注解，要么通过编程配置。\n请注意，核心BeanFactory API级别及其DefaultListableBeanFactory实现不对要使用的配置格式或任何组件注释进行假设。所有这些风格都是通过扩展（如XmlBeanDefinitionReader和AutowiredNotationBeanPostProcessor）引入的，并作为核心元数据表示在共享BeanDefinition对象上操作。这就是Spring容器如此灵活和可扩展的本质所在。\n=== BeanFactory还是ApplicationContext？\n本节讲解BeanFactory和ApplicationContext容器级别之间的差异以及对引导的影响。\n除非有充分的理由，否则你应该使用ApplicationContext，将GenericaApplicationContext及其子类AnnotationConfigApplicationContext作为自定义引导的常见实现。这些是Spring核心容器的主要切入点，用于所有常见目的：加载配置文件、触发类路径扫描、以编程方式注册bean定义和注解类，以及（从5.0开始）注册函数bean定义。\n = 资源\n== 应用上下文与资源路径\n === 使用AspectJ向Spring注入依赖域对象  "}]